<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>AR MULTIMUSIC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <style>
      /* Permitir scroll vertical en el body */
      body {
        margin: 0;
        font-family: sans-serif;
        overflow-y: auto;
      }
      /* Overlay del menú inicial */
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        min-height: 100vh;
        background-color: orange;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        text-align: center;
        z-index: 10;
        overflow-y: auto;
        box-sizing: border-box;
        padding: 20px;
      }
      #overlay a {
        font-size: 14px;
        margin-top: 10px;
        margin-bottom: 20px;
        color: blue;
        text-decoration: none;
      }
      /* Contenedor para el selector de respuestas */
      #overlay .respuestas-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      #overlay .respuestas-container label {
        font-size: 14px;
        color: black;
      }
      #overlay .respuestas-container select {
        font-size: 14px;
      }
      /* Imagen */
      #overlay img {
        border-radius: 20px;
        max-width: 15%;
        margin-top: 50px;
        margin-bottom: 10px;
      }
      @media (orientation: portrait) {
        #overlay img {
          max-width: 70%;
        }
      }
      /* Tabla de clasificación en el overlay */
      #leaderboardPreview {
        max-width: 80%;
        max-height: 120px;
        overflow-y: auto;
        background-color: #fff;
        color: #000;
        font-size: 12px;
        margin-bottom: 20px;
        border: 1px solid #000;
        border-radius: 6px;
        padding: 4px;
      }
      #leaderboardPreview table {
        border-collapse: collapse;
        width: 100%;
      }
      #leaderboardPreview th, #leaderboardPreview td {
        border: 1px solid #666;
        padding: 4px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <!-- Audios: acierto, error, timer y beep -->
    <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/acierto.wav" preload="auto"></audio>
    <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/error.wav" preload="auto"></audio>
    <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/timer7.mp3" preload="auto"></audio>
    <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>

    <script type="module">
      /***** 1) Firebase y Firestore *****/
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
      import { 
        getFirestore, collection, addDoc, orderBy, getDocs, serverTimestamp,
        query, where, limit, updateDoc, doc
      } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

      // Configura tu proyecto
      const firebaseConfig = {
        apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
        authDomain: "arm1-acbba.firebaseapp.com",
        projectId: "arm1-acbba",
        storageBucket: "arm1-acbba.firebasestorage.app",
        messagingSenderId: "408825932019",
        appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
        measurementId: "G-S78TM6PVRL"
      };

      // Inicializar Firebase
      const appFirebase = initializeApp(firebaseConfig);
      const analytics = getAnalytics(appFirebase);
      const db = getFirestore(appFirebase);

      /***** Función para cargar y mostrar el top 5 en el overlay *****/
      async function updateLeaderboardPreview(numAnswers) {
        const collectionName = `leaderboard_${numAnswers}`;
        try {
          let top5Query = query(
            collection(db, collectionName),
            orderBy("score", "desc"),
            limit(3)
          );
          const querySnapshot = await getDocs(top5Query);
          const results = [];
          querySnapshot.forEach((docSnap) => {
            results.push(docSnap.data());
          });

          const container = document.getElementById('leaderboardPreview');
          container.innerHTML = ""; // Limpia previo

          if (results.length > 0) {
            let html = "<table>";
            html += "<tr><th>Pos</th><th>Nombre</th><th>Puntos</th></tr>";
            for (let i = 0; i < results.length; i++) {
              html += `<tr>
                <td>${i+1}</td>
                <td>${results[i].name}</td>
                <td>${results[i].score}</td>
              </tr>`;
            }
            html += "</table>";
            container.innerHTML = html;
          } else {
            container.innerHTML = "<p>No hay puntuaciones aún.</p>";
          }
        } catch (err) {
          console.error("Error cargando top 5:", err);
          document.getElementById('leaderboardPreview').innerHTML =
            "<p>Error cargando clasificación.</p>";
        }
      }

      /***** 2) Código AR y juego *****/
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;

      // Variables para distinguir el modo de juego
      let isARMode = false;  // Será true si el dispositivo soporta AR
      // En HTML mode se ejecuta la misma lógica, pero sin XR

      // Pregunta y respuestas
      let correctAnswer;
      let answers = [];
      let hasCollided = false;
      let questionMesh = null;
      let questionText = "";

      // Aumentamos un poco el umbral de colisión
      const collisionThreshold = 0.3;

      // Contadores y variables de tiempo
      let correctCount = 0;
      let wrongCount = 0;
      let currentQuestionStartTime = 0; // Inicia el tiempo al mostrar cada pregunta
      let correctResponseTimes = [];    // Array para almacenar los tiempos de respuesta correctos

      // Tiempo de juego
      let gameStartTime = 0;
      const gameDuration = 60;
      let gameOver = false;

      // Mallas (HUD en AR o HTML)
      let countdownMesh = null;
      let scoreMesh = null;

      // Leaderboard (tabla en AR)
      let leaderboardMesh = null;
      let restartButtonMesh = null;
      let scrollUpButtonMesh = null;
      let scrollDownButtonMesh = null;

      // Config flotación
      let originalAnswerTransforms = null;

      // Control beep
      let beepPlayed = false;

      // Lógica de inicio
      let gameReady = false;
      let countdownStarted = false;

      // Factor p/ resoluciones de canvas
      const resolutionFactor = 4;

      // Nombre del jugador y número de respuestas
      let playerName = "";
      let selectedNumAnswers = 4;

      // Lista de sistemas de chispas
      const sparksSystems = [];

      // Variables para manejar la tabla completa y la “paginación” (final en AR)
      let leaderboardResults = [];      
      let scoreboardStartIndex = 0;     
      const pageSize = 10;             
      let playerPosition = null;

      /***** 2.1) Funciones auxiliares (sin cambios) *****/
      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      // Textura circular para chispas
      function createCircleTexture() {
        const size = 128;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
      }

      // Crear un mesh a partir de un canvas (retorna la malla)
      function createCanvasPlane(canvas, ctx, width, height) {
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(width, height);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData.canvas = canvas;
        mesh.userData.ctx = ctx;
        mesh.userData.texture = texture;
        return mesh;
      }

      // Crear un botón en AR (o para interfaz 3D en modo HTML)
      function createButton(text, planeWidth = 0.3, planeHeight = 0.1) {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 64 * resolutionFactor;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geom = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        return new THREE.Mesh(geom, mat);
      }

      // Actualizar un panel con valor de respuesta
      function updateAnswerPanel(mesh, value) {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 256 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        mesh.material.map = texture;
        mesh.material.transparent = true;
        mesh.material.needsUpdate = true;
        mesh.userData.answer = value;
      }

      /***** 2.2) Inicializar AR / HTML *****/
      function init() {
        // Crear escena, cámara y renderer
        scene = new THREE.Scene();
        // La cámara se crea igual en ambos modos (nota: en HTML, se usará el mismo setup 3D)
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        // En modo AR, XR se habilitará; en HTML, se deja deshabilitado
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = isARMode;
        document.body.appendChild(renderer.domElement);

        // En HTML mode la cámara se ubica en (0,0,0) mirando hacia -Z (igual que AR)
        // Agregar luz
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        window.addEventListener('resize', onWindowResize, false);

        // Crear overlay inicial
        const overlay = document.createElement('div');
        overlay.id = 'overlay';
        overlay.innerHTML = `
          <img src="ARM2.jpeg" alt="AR Mult">
          <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
          <div class="respuestas-container">
            <label for="numAnswers">Respuestas:</label>
            <select id="numAnswers">
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </div>
          <!-- Tabla "preview" del top 5 -->
          <div id="leaderboardPreview"></div>
  
          <input
            type="text"
            id="playerName"
            placeholder="Ingresa tu nombre"
            style="padding:10px; font-size:16px; margin-bottom:20px;"
            maxlength="10"
          >
        `;

        // Si el dispositivo soporta AR se crea el botón AR, de lo contrario un botón HTML
        if (isARMode) {
          // Para AR, usar ARButton con las características requeridas
          const requiredFeatures = /Mobi|Android/i.test(navigator.userAgent)
            ? ['hit-test']
            : ['hit-test','hand-tracking'];
          const arButton = ARButton.createButton(renderer, { requiredFeatures });
          // Ajustar estilos y ubicar el botón en el overlay
          if (arButton.parentNode) {
            arButton.parentNode.removeChild(arButton);
          }
          arButton.style.position = 'absolute';
          arButton.style.top = '600px';
          arButton.style.left = '100%';
          arButton.style.transform = 'translateX(0%)';
          arButton.style.width = '150px';
          arButton.style.height = '50px';
          arButton.style.fontSize = '16px';
          arButton.style.backgroundColor = 'green';
          arButton.style.color = 'white';
          overlay.appendChild(arButton);

          // Cuando inicie la sesión AR se arrancan las funciones del juego
          renderer.xr.addEventListener('sessionstart', () => {
            selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
            playerName = document.getElementById('playerName').value || "Jugador";
            createAnswerObjects(selectedNumAnswers, true);
            overlay.remove();
            generateQuestion();
            createScoreDisplay();
            gameReady = true;
          });
        } else {
          // En modo HTML, crear un botón “Iniciar juego”
          const htmlButton = document.createElement('button');
          htmlButton.textContent = 'Iniciar juego';
          htmlButton.style.position = 'absolute';
          htmlButton.style.top = '600px';
          htmlButton.style.left = '100%';
          htmlButton.style.transform = 'translateX(0%)';
          htmlButton.style.width = '150px';
          htmlButton.style.height = '50px';
          htmlButton.style.fontSize = '16px';
          htmlButton.style.backgroundColor = 'green';
          htmlButton.style.color = 'white';
          htmlButton.addEventListener('click', () => {
            selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
            playerName = document.getElementById('playerName').value || "Jugador";
            createAnswerObjects(selectedNumAnswers, true);
            overlay.remove();
            generateQuestion();
            createScoreDisplay();
            gameReady = true;
          });
          overlay.appendChild(htmlButton);
        }

        document.body.appendChild(overlay);

        // Actualizar el top 5 cada vez que cambia el número de respuestas
        const selectAnswers = document.getElementById('numAnswers');
        selectAnswers.addEventListener('change', () => {
          const num = parseInt(selectAnswers.value) || 4;
          updateLeaderboardPreview(num);
        });
        updateLeaderboardPreview(4);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      /***** 2.3) Lógica del juego (se reutiliza para AR y HTML) *****/
      // Iniciar el countdown
      function startCountdown() {
        gameStartTime = performance.now();
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 128 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        countdownMesh = createCanvasPlane(canvas, ctx, 0.6, 0.3);
        // En ambos modos se ubica en z negativo (la cámara mira hacia -Z)
        countdownMesh.position.set(0, 0.50, -0.82);
        scene.add(countdownMesh);
      }

      // Crear display de aciertos/fallos
      function createScoreDisplay() {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 128 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        scoreMesh = createCanvasPlane(canvas, ctx, 0.6, 0.3);
        scoreMesh.position.set(0, -0.2, -0.82);
        scene.add(scoreMesh);
      }

      // Actualizar countdown
      function updateCountdown() {
        if (!countdownMesh) return;
        const { canvas, ctx, texture } = countdownMesh.userData;
        const elapsed = (performance.now() - gameStartTime) / 1000;
        const remaining = Math.max(0, gameDuration - elapsed);
        const seconds = Math.floor(remaining);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = (remaining <= 10) ? "red" : "#FFFFFF";
        ctx.font = 'Bold ' + (64 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(seconds < 10 ? "00:0" + seconds : "00:" + seconds, canvas.width / 2, canvas.height / 2);

        texture.needsUpdate = true;

        if (remaining <= 10 && !beepPlayed) {
          const beepSound = document.getElementById('beepSound');
          beepSound.currentTime = 0;
          beepSound.play().catch((e) => console.error(e));
          beepPlayed = true;
        }
        return remaining;
      }

      // Actualizar aciertos/fallos
      function updateScoreDisplay() {
        if (!scoreMesh) return;
        const { canvas, ctx, texture } = scoreMesh.userData;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`Aciertos: ${correctCount} | Fallos: ${wrongCount}`, canvas.width / 2, canvas.height / 2);
        texture.needsUpdate = true;
      }

      // Generar pregunta y actualizar paneles
      function generateQuestion() {
        const a = Math.floor(Math.random() * 10) + 1;
        const b = Math.floor(Math.random() * 10) + 1;
        correctAnswer = a * b;
        questionText = `¿Cuánto es ${a} x ${b}?`;

        if (questionMesh) {
          scene.remove(questionMesh);
          questionMesh = null;
        }
        updateQuestionPanel();
        updateAnswerObjects();
        beepPlayed = false;

        currentQuestionStartTime = performance.now();
      }

      // Panel de pregunta
      function updateQuestionPanel() {
        const canvas = document.createElement('canvas');
        canvas.width = 512 * resolutionFactor;
        canvas.height = 128 * resolutionFactor;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.font = 'Bold ' + (48 * resolutionFactor) + 'px Arial';
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(0.6, 0.15);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        questionMesh = new THREE.Mesh(geometry, material);
        questionMesh.position.set(0, 0.3, -0.8);
        scene.add(questionMesh);
      }

      // Crear los paneles de respuesta
      function createAnswerObjects(numAnswers, initialCreation) {
        if (initialCreation) {
          const minArc = 1.39626;
          const maxArc = Math.PI;
          let arcAngle;
          if (numAnswers <= 4) {
            arcAngle = minArc;
          } else if (numAnswers >= 10) {
            arcAngle = maxArc;
          } else {
            arcAngle = minArc + ((numAnswers - 4) / (10 - 4)) * (maxArc - minArc);
          }
          const angleStart = -arcAngle / 2;
          const angleEnd = arcAngle / 2;
          const radius = 0.8;

          originalAnswerTransforms = [];

          for (let i = 0; i < numAnswers; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = 256 * resolutionFactor;
            canvas.height = 256 * resolutionFactor;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#007BFF";
            drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
            ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
            ctx.fillStyle = "#FFFFFF";
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("?", canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
            const geometry = new THREE.PlaneGeometry(0.15, 0.15);
            const mesh = new THREE.Mesh(geometry, material);

            const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
            const x = radius * Math.sin(angle);
            const z = -radius * Math.cos(angle);
            mesh.position.set(x, 0, z);

            // Hacer que mire hacia la cámara
            const cameraWorldPos = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPos);
            const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
            mesh.lookAt(lookAtPos);

            mesh.userData.answer = 0;
            answers.push(mesh);
            scene.add(mesh);

            originalAnswerTransforms.push({
              position: mesh.position.clone(),
              rotation: mesh.rotation.clone(),
            });
          }
        } else {
          const numAnswersExisting = selectedNumAnswers;
          const wrongAnswers = new Set();
          while (wrongAnswers.size < numAnswersExisting - 1) {
            let wrong = Math.floor(Math.random() * 100) + 1;
            if (wrong !== correctAnswer) wrongAnswers.add(wrong);
          }
          const answersArray = [correctAnswer, ...wrongAnswers];
          answersArray.sort(() => Math.random() - 0.5);

          for (let i = 0; i < numAnswersExisting; i++) {
            updateAnswerPanel(answers[i], answersArray[i]);
          }
        }
      }

      // Actualizar las respuestas para nueva pregunta
      function updateAnswerObjects() {
        createAnswerObjects(selectedNumAnswers, false);
      }

      // Efecto chispas
      function createSparksEffect(position) {
        const count = 100;
        const positions = new Float32Array(count * 3);
        const velocities = [];
        for (let i = 0; i < count; i++) {
          positions[i * 3] = position.x;
          positions[i * 3 + 1] = position.y;
          positions[i * 3 + 2] = position.z;
          velocities.push(
            new THREE.Vector3(
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5
            )
          );
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        if (!window.sparkTexture) {
          window.sparkTexture = createCircleTexture();
        }
        const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.02,
          map: window.sparkTexture,
          transparent: true,
          depthWrite: false,
        });
        const points = new THREE.Points(geometry, material);
        scene.add(points);
        sparksSystems.push({
          points,
          velocities,
          startTime: performance.now(),
          lastUpdate: performance.now(),
        });
      }

      // Bucle principal
      function animate() {
        renderer.setAnimationLoop(render);
      }

      // Render con detección de colisiones
      function render(timestamp, xrFrame) {
        renderer.render(scene, camera);

        answers.forEach((panel, index) => {
          if (!originalAnswerTransforms[index]) return;
          const baseY = originalAnswerTransforms[index].position.y;
          panel.position.y = baseY + 0.02 * Math.sin(timestamp * 0.005 + index);
        });

        if (gameReady && !countdownStarted) {
          startCountdown();
          const timerSound = document.getElementById('timerSound');
          timerSound.loop = false;
          timerSound.play().catch((e) => console.error(e));
          countdownStarted = true;
        }

        // Actualizar efectos de chispas
        const currentTime = performance.now();
        for (let i = sparksSystems.length - 1; i >= 0; i--) {
          const system = sparksSystems[i];
          const dt = (currentTime - system.lastUpdate) / 1000;
          system.lastUpdate = currentTime;
          const positions = system.points.geometry.attributes.position.array;
          for (let j = 0; j < system.velocities.length; j++) {
            positions[j * 3] += system.velocities[j].x * dt;
            positions[j * 3 + 1] += system.velocities[j].y * dt;
            positions[j * 3 + 2] += system.velocities[j].z * dt;
          }
          system.points.geometry.attributes.position.needsUpdate = true;
          const elapsedTime = currentTime - system.startTime;
          if (elapsedTime > 1700) {
            const fadeProgress = (elapsedTime - 1700) / 300;
            system.points.material.opacity = Math.max(1 - fadeProgress, 0);
          }
          if (elapsedTime > 2000) {
            scene.remove(system.points);
            sparksSystems.splice(i, 1);
          }
        }

        if (!gameOver) {
          const remaining = updateCountdown();
          updateScoreDisplay();
          if (remaining <= 0) {
            endGame();
          }
        }

        // Detección de colisión: en AR se usan las manos/cámara; en HTML, se usará el raycasting del touch
        const session = renderer.xr.getSession();
        let interactionPoints = [];
        if (session && xrFrame) {
          for (const inputSource of session.inputSources) {
            if (inputSource.hand) {
              const indexTip = inputSource.hand.get('index-finger-tip');
              if (indexTip) {
                const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                if (jointPose) {
                  interactionPoints.push(
                    new THREE.Vector3(
                      jointPose.transform.position.x,
                      jointPose.transform.position.y,
                      jointPose.transform.position.z
                    )
                  );
                }
              }
            }
          }
        }
        if (interactionPoints.length === 0) {
          let cameraPos = new THREE.Vector3();
          camera.getWorldPosition(cameraPos);
          interactionPoints.push(cameraPos);
        }

        if (!gameOver) {
          for (let panel of answers) {
            const panelPos = new THREE.Vector3();
            panel.getWorldPosition(panelPos);
            for (const point of interactionPoints) {
              const distance = point.distanceTo(panelPos);
              if (distance < collisionThreshold && !hasCollided) {
                hasCollided = true;
                if (panel.userData.answer === correctAnswer) {
                  let responseTime = performance.now() - currentQuestionStartTime;
                  correctResponseTimes.push(responseTime);
                  console.log("¡Colisión 3D con respuesta CORRECTA!");
                  correctCount++;
                  const successSound = document.getElementById('successSound');
                  const successClone = successSound.cloneNode();
                  successClone.play().catch((e) => console.error(e));
                  createSparksEffect(panel.position);
                  if (questionMesh) questionMesh.visible = false;
                  answers.forEach((a) => (a.visible = false));
                  setTimeout(() => {
                    if (!gameOver) {
                      generateQuestion();
                      if (questionMesh) questionMesh.visible = true;
                      answers.forEach((a) => (a.visible = true));
                    }
                    hasCollided = false;
                  }, 1000);
                } else {
                  console.log("¡Colisión 3D con respuesta ERRÓNEA!");
                  wrongCount++;
                  const errorSound = document.getElementById('errorSound');
                  const errorClone = errorSound.cloneNode();
                  errorClone.play().catch((e) => console.error(e));
                  answers.forEach((a) => a.material.color.set(0xff0000));
                  setTimeout(() => {
                    answers.forEach((a) => a.material.color.set(0xffffff));
                    hasCollided = false;
                  }, 500);
                }
                return;
              }
            }
          }
        } else {
          // Colisiones con botones al finalizar el juego
          let finalButtons = [];
          if (restartButtonMesh) finalButtons.push(restartButtonMesh);
          if (scrollUpButtonMesh) finalButtons.push(scrollUpButtonMesh);
          if (scrollDownButtonMesh) finalButtons.push(scrollDownButtonMesh);

          for (const btn of finalButtons) {
            if (!btn.visible) continue;
            const btnPos = new THREE.Vector3();
            btn.getWorldPosition(btnPos);
            for (const point of interactionPoints) {
              const distance = point.distanceTo(btnPos);
              if (distance < collisionThreshold && !hasCollided) {
                hasCollided = true;
                console.log("¡Colisión 3D con botón final!");
                if (btn === restartButtonMesh) {
                  const successSound = document.getElementById('successSound');
                  const successClone = successSound.cloneNode();
                  successClone.play().catch((e) => console.error(e));
                  createSparksEffect(btn.position);
                  btn.visible = false;
                  setTimeout(() => {
                    restartGame();
                    hasCollided = false;
                  }, 1000);
                } else if (btn === scrollUpButtonMesh) {
                  scoreboardStartIndex -= pageSize;
                  if (scoreboardStartIndex < 0) scoreboardStartIndex = 0;
                  drawLeaderboardSegment();
                  setTimeout(() => { hasCollided = false; }, 500);
                } else if (btn === scrollDownButtonMesh) {
                  scoreboardStartIndex += pageSize;
                  if (scoreboardStartIndex >= leaderboardResults.length) {
                    scoreboardStartIndex = leaderboardResults.length - pageSize;
                    if (scoreboardStartIndex < 0) scoreboardStartIndex = 0;
                  }
                  drawLeaderboardSegment();
                  setTimeout(() => { hasCollided = false; }, 500);
                }
                return;
              }
            }
          }
        }
      }

      // Touch en pantallas móviles (raycasting con taps)
      window.addEventListener(
        'touchstart',
        function (event) {
          if (!/Mobi|Android/i.test(navigator.userAgent)) return;
          const touch = event.touches[0];
          const x = (touch.clientX / window.innerWidth) * 2 - 1;
          const y = -(touch.clientY / window.innerHeight) * 2 + 1;
          const mouseVector = new THREE.Vector2(x, y);
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouseVector, camera);

          let objectsToIntersect = [];
          if (!gameOver) {
            objectsToIntersect = answers;
          } else {
            let finalButtons = [];
            if (restartButtonMesh) finalButtons.push(restartButtonMesh);
            if (scrollUpButtonMesh) finalButtons.push(scrollUpButtonMesh);
            if (scrollDownButtonMesh) finalButtons.push(scrollDownButtonMesh);
            objectsToIntersect = finalButtons;
          }

          const intersects = raycaster.intersectObjects(objectsToIntersect);
          if (intersects.length > 0 && !hasCollided) {
            const objHit = intersects[0].object;
            hasCollided = true;
            if (!gameOver) {
              if (objHit.userData.answer === correctAnswer) {
                let responseTime = performance.now() - currentQuestionStartTime;
                correctResponseTimes.push(responseTime);
                console.log("¡Toque en pantalla - respuesta CORRECTA!");
                correctCount++;
                const successSound = document.getElementById('successSound');
                const successClone = successSound.cloneNode();
                successClone.play().catch((e) => console.error(e));
                createSparksEffect(objHit.position);
                if (questionMesh) questionMesh.visible = false;
                answers.forEach((a) => (a.visible = false));
                setTimeout(() => {
                  if (!gameOver) {
                    generateQuestion();
                    if (questionMesh) questionMesh.visible = true;
                    answers.forEach((a) => (a.visible = true));
                  }
                  hasCollided = false;
                }, 1000);
              } else {
                console.log("¡Toque en pantalla - respuesta ERRÓNEA!");
                wrongCount++;
                const errorSound = document.getElementById('errorSound');
                const errorClone = errorSound.cloneNode();
                errorClone.play().catch((e) => console.error(e));
                answers.forEach((a) => a.material.color.set(0xff0000));
                setTimeout(() => {
                  answers.forEach((a) => a.material.color.set(0xffffff));
                  hasCollided = false;
                }, 500);
              }
            } else {
              console.log("¡Toque en pantalla - botón final!");
              if (objHit === restartButtonMesh) {
                const successSound = document.getElementById('successSound');
                const successClone = successSound.cloneNode();
                successClone.play().catch((e) => console.error(e));
                createSparksEffect(objHit.position);
                objHit.visible = false;
                setTimeout(() => {
                  restartGame();
                  hasCollided = false;
                }, 1000);
              } else if (objHit === scrollUpButtonMesh) {
                scoreboardStartIndex -= pageSize;
                if (scoreboardStartIndex < 0) scoreboardStartIndex = 0;
                drawLeaderboardSegment();
                setTimeout(() => { hasCollided = false; }, 500);
              } else if (objHit === scrollDownButtonMesh) {
                scoreboardStartIndex += pageSize;
                if (scoreboardStartIndex >= leaderboardResults.length) {
                  scoreboardStartIndex = leaderboardResults.length - pageSize;
                  if (scoreboardStartIndex < 0) scoreboardStartIndex = 0;
                }
                drawLeaderboardSegment();
                setTimeout(() => { hasCollided = false; }, 500);
              }
            }
          }
        },
        false
      );

      /***** 2.4) Al finalizar el juego *****/
      async function endGame() {
        gameOver = true;

        if (questionMesh) scene.remove(questionMesh);
        if (countdownMesh) scene.remove(countdownMesh);
        if (scoreMesh) scene.remove(scoreMesh);
        answers.forEach((panel) => scene.remove(panel));

        let avgTime = 0;
        if (correctResponseTimes.length > 0) {
          let sumTimes = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sumTimes / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));

        const collectionName = `leaderboard_${selectedNumAnswers}`;

        let docsFound = await getDocs(
          query(
            collection(db, collectionName),
            where("name", "==", playerName),
            limit(1)
          )
        );

        if (!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }

        let qLeaderboard = query(
          collection(db, collectionName),
          orderBy("score", "desc")
        );
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch (err) {
          console.error("Error consultando el leaderboard:", err);
          return;
        }

        leaderboardResults = [];
        let idx = 0;
        querySnapshot.forEach((docSnap) => {
          let data = docSnap.data();
          leaderboardResults.push({ ...data, _index: idx });
          idx++;
        });

        let playerIndex = leaderboardResults.findIndex(
          (r) => r.name === playerName && r.score === finalScore
        );
        playerPosition = (playerIndex >= 0) ? (playerIndex + 1) : null;

        scoreboardStartIndex = playerIndex - Math.floor(pageSize / 2);
        if (scoreboardStartIndex < 0) scoreboardStartIndex = 0;
        if (scoreboardStartIndex >= leaderboardResults.length) {
          scoreboardStartIndex = 0;
        }

        createLeaderboardMesh();
        drawLeaderboardSegment();
      }

      // Crear la malla leaderboard y botones
      function createLeaderboardMesh() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);

        const dummyCanvas = document.createElement('canvas');
        dummyCanvas.width = 512;
        dummyCanvas.height = 512; 
        const ctx = dummyCanvas.getContext('2d');

        const lbTexture = new THREE.CanvasTexture(dummyCanvas);
        lbTexture.minFilter = THREE.LinearFilter;
        lbTexture.magFilter = THREE.LinearFilter;

        const planeWidth = 1.2;
        const planeHeight = 1.0;
        const lbGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const lbMaterial = new THREE.MeshBasicMaterial({ map: lbTexture, transparent: true });
        leaderboardMesh = new THREE.Mesh(lbGeometry, lbMaterial);

        leaderboardMesh.userData.canvas = dummyCanvas;
        leaderboardMesh.userData.ctx = ctx;
        leaderboardMesh.userData.texture = lbTexture;
        leaderboardMesh.userData.planeWidth = planeWidth;
        leaderboardMesh.userData.planeHeight = planeHeight;

        leaderboardMesh.position.set(0, 0, -1.2);
        scene.add(leaderboardMesh);

        restartButtonMesh = createButton("Reiniciar");
        restartButtonMesh.position.set(0, -0.8, -1.1);
        scene.add(restartButtonMesh);

        scrollUpButtonMesh = createButton("▲", 0.1, 0.1);
        scrollUpButtonMesh.position.set(-0.6, 0.5, -1.1); 
        scene.add(scrollUpButtonMesh);

        scrollDownButtonMesh = createButton("▼", 0.1, 0.1);
        scrollDownButtonMesh.position.set(-0.6, -0.4, -1.1);
        scene.add(scrollDownButtonMesh);
      }

      function drawLeaderboardSegment() {
        if (!leaderboardMesh) return;
        const { canvas, ctx, texture, planeWidth } = leaderboardMesh.userData;

        const subset = leaderboardResults.slice(scoreboardStartIndex, scoreboardStartIndex + pageSize);

        const lineHeight = 40 * resolutionFactor;
        const extraLines = 4; 
        const canvasWidth = 512 * resolutionFactor;
        const canvasHeight = lineHeight * (subset.length + extraLines);

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0,0, canvasWidth, canvasHeight);

        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (28 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
          `Tabla de Clasificación`,
          canvasWidth / 2,
          lineHeight
        );

        const xPosPos   = 0.10 * canvasWidth; 
        const xPosName  = 0.40 * canvasWidth;
        const xPosScore = 0.75 * canvasWidth;

        let startY = lineHeight * 2.5;
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "left";

        ctx.fillText("Pos",    xPosPos,   startY);
        ctx.fillText("Nombre", xPosName,  startY);
        ctx.fillText("Puntos", xPosScore, startY);

        let yPos = startY + (1.5 * lineHeight);

        for (let i = 0; i < subset.length; i++) {
          const data = subset[i];
          const realPos = data._index + 1; 
          if (playerPosition !== null && realPos === playerPosition) {
            ctx.fillStyle = "green";
            ctx.fillRect(0, yPos - lineHeight * 0.6, canvasWidth, lineHeight);
            ctx.fillStyle = "#FFFFFF";
          } else {
            ctx.fillStyle = "#FFFFFF";
          }
          ctx.fillText(String(realPos),  xPosPos,   yPos);
          ctx.fillText(data.name,        xPosName,  yPos);
          ctx.fillText(String(data.score), xPosScore,yPos);

          yPos += lineHeight;
        }

        if (playerPosition !== null) {
          ctx.textAlign = "center";
          ctx.fillText(
            `Tu posición: ${playerPosition}`,
            canvasWidth / 2,
            yPos + lineHeight
          );
        }

        texture.needsUpdate = true;

        const planeHeight = planeWidth * (canvasHeight / canvasWidth);
        leaderboardMesh.geometry.dispose();
        leaderboardMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

        leaderboardMesh.position.set(0, 0.0, -1.2);

        restartButtonMesh.position.set(0, -planeHeight*0.6, -1.1);
        scrollUpButtonMesh.position.set(-planeWidth*0.5 - 0.1, planeHeight*0.35, -1.1);
        scrollDownButtonMesh.position.set(-planeWidth*0.5 - 0.1, -planeHeight*0.35, -1.1);
      }

      function restartGame() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);

        leaderboardMesh = null;
        restartButtonMesh = null;
        scrollUpButtonMesh = null;
        scrollDownButtonMesh = null;
        leaderboardResults = [];
        scoreboardStartIndex = 0;
        playerPosition = null;

        if (questionMesh) {
          scene.remove(questionMesh);
          questionMesh = null;
        }
        correctCount = 0;
        wrongCount = 0;
        gameStartTime = performance.now();
        gameOver = false;
        answers.forEach((panel) => scene.remove(panel));
        answers = [];

        createAnswerObjects(selectedNumAnswers, true);
        generateQuestion();
        countdownStarted = false;
        gameReady = true;
        createScoreDisplay();

        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime = 0;
        timerSound.loop = false;
        timerSound.play().catch((e) => console.error(e));
      }

      /***** 2.5) Eventos de audio en iOS/Android *****/
      window.addEventListener(
        'touchstart',
        function unlockAudio() {
          const successEl = document.getElementById('successSound');
          const errorEl = document.getElementById('errorSound');
          [successEl, errorEl].forEach((audioEl) => {
            audioEl
              .play()
              .then(() => {
                audioEl.pause();
                audioEl.currentTime = 0;
              })
              .catch((e) => console.error(e));
          });
        },
        { once: true }
      );

      /***** Inicialización según compatibilidad con AR *****/
      async function checkARSupport() {
        if (navigator.xr && navigator.xr.isSessionSupported) {
          try {
            isARMode = await navigator.xr.isSessionSupported('immersive-ar');
          } catch(e) {
            isARMode = false;
          }
        }
        // Llama a init() y animate() en ambos modos
        init();
        animate();
      }

      checkARSupport();
    </script>
  </body>
</html>
