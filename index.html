<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>AR MULTIMUSIC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
      }
      /* Solo se usa CSS básico ya que la UI se crea en AR */
    </style>
  </head>
  <body>
    <!-- Audios: acierto, error, timer y beep -->
    <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/acierto.wav" preload="auto"></audio>
    <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/error.wav" preload="auto"></audio>
    <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/timer7.mp3" preload="auto"></audio>
    <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>

    <!-- Overlay inicial (HTML) solo para la selección del número de respuestas y el botón AR -->
    <div id="overlay" style="position: absolute; width:100%; height:100%; background: orange; display:flex; flex-direction:column; justify-content:center; align-items:center;">
      <img src="ARM2.jpeg" alt="AR Mult" style="margin-bottom:20px; border-radius:20px; max-width:15%;">
      <a href="https://www.youtube.com/@rafgim" target="_blank" style="font-size:14px; margin-bottom:20px; color:blue; text-decoration:none;">© By Rafael Gimeno</a>
      <div class="respuestas-container" style="display:flex; align-items:center; gap:10px; margin-bottom:20px;">
        <label for="numAnswers" style="font-size:14px; color:black;">Respuestas:</label>
        <select id="numAnswers" style="font-size:14px;">
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="9">9</option>
          <option value="10">10</option>
        </select>
      </div>
      <!-- El botón AR se añadirá a la escena -->
    </div>

    <script type="module">
      // ------------------ Firebase Initialization ------------------
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
      import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
        authDomain: "arm1-acbba.firebaseapp.com",
        projectId: "arm1-acbba",
        storageBucket: "arm1-acbba.firebasestorage.app",
        messagingSenderId: "408825932019",
        appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
        measurementId: "G-S78TM6PVRL"
      };

      const firebaseApp = initializeApp(firebaseConfig);
      const analytics = getAnalytics(firebaseApp);
      const db = getFirestore(firebaseApp);
      // ------------------ Fin Firebase Initialization ------------------

      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;
      let correctAnswer;
      let answers = []; // Paneles de respuesta
      let hasCollided = false;
      let questionMesh = null;
      let questionText = "";
      const collisionThreshold = 0.2;
      const sparksSystems = [];

      // Contadores de aciertos y fallos
      let correctCount = 0;
      let wrongCount = 0;

      // Variables para el tiempo de juego
      let gameStartTime = 0;
      const gameDuration = 60; // segundos
      let gameOver = false;

      // Mallas AR: cuenta atrás, score
      let countdownMesh = null,
          countdownCanvas = null,
          countdownCtx = null,
          countdownTexture = null;
      let scoreMesh = null,
          scoreCanvas = null,
          scoreCtx = null,
          scoreTexture = null;

      // Número de respuestas seleccionado
      let selectedNumAnswers = 4;

      // Almacenar posición original de los paneles de respuesta
      let originalAnswerTransforms = null;

      // Control para el beep
      let beepPlayed = false;

      // Control del inicio del countdown
      let gameReady = false;
      let countdownStarted = false;

      // Factor para mejorar resolución de canvas
      const resolutionFactor = 4;

      // Variable global para el panel de nombre (se crea al finalizar el juego)
      let namePanel = null;

      // ------------------ Funciones Canvas para crear texturas ------------------
      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      function createButton(text) {
        const canvas = document.createElement('canvas');
        canvas.width = 128 * resolutionFactor;
        canvas.height = 64 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(0.3, 0.15);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const button = new THREE.Mesh(geometry, material);
        button.userData.canvas = canvas;
        button.userData.ctx = ctx;
        return button;
      }

      // ------------------ Inicialización AR ------------------
      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        window.addEventListener('resize', onWindowResize, false);

        // Mostrar overlay HTML inicial para escoger número de respuestas
        const overlay = document.getElementById('overlay');
        // Creamos el botón AR y lo añadimos al overlay (se quitará al iniciar sesión AR)
        const arButton = ARButton.createButton(renderer, { 
          requiredFeatures: /Mobi|Android/i.test(navigator.userAgent) ? ['hit-test'] : ['hit-test','hand-tracking'] 
        });
        arButton.style.position = 'absolute';
        arButton.style.top = '450px';
        arButton.style.left = '100%';
        arButton.style.transform = 'translateX(0%)';
        arButton.style.width = '150px';
        arButton.style.height = '50px';
        arButton.style.fontSize = '16px';
        arButton.style.backgroundColor = 'green';
        arButton.style.color = 'white';
        overlay.appendChild(arButton);

        renderer.xr.addEventListener('sessionstart', () => {
          selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
          createAnswerObjects(selectedNumAnswers, true);
          overlay.remove();
          generateQuestion();
          createScoreDisplay();
          gameReady = true;
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ------------------ Funciones para cuenta regresiva y score ------------------
      function startCountdown() {
        gameStartTime = performance.now();
        countdownCanvas = document.createElement('canvas');
        countdownCanvas.width = 256 * resolutionFactor;
        countdownCanvas.height = 128 * resolutionFactor;
        countdownCtx = countdownCanvas.getContext('2d');
        countdownTexture = new THREE.CanvasTexture(countdownCanvas);
        countdownTexture.minFilter = THREE.LinearFilter;
        countdownTexture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(0.6, 0.3);
        const material = new THREE.MeshBasicMaterial({ map: countdownTexture, transparent: true });
        countdownMesh = new THREE.Mesh(geometry, material);
        countdownMesh.position.set(0, 0.50, -0.82);
        scene.add(countdownMesh);
      }

      function createScoreDisplay() {
        scoreCanvas = document.createElement('canvas');
        scoreCanvas.width = 256 * resolutionFactor;
        scoreCanvas.height = 128 * resolutionFactor;
        scoreCtx = scoreCanvas.getContext('2d');
        scoreTexture = new THREE.CanvasTexture(scoreCanvas);
        scoreTexture.minFilter = THREE.LinearFilter;
        scoreTexture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(0.6, 0.3);
        const material = new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true });
        scoreMesh = new THREE.Mesh(geometry, material);
        scoreMesh.position.set(0, -0.2, -0.82);
        scene.add(scoreMesh);
      }

      function updateCountdown() {
        const elapsed = (performance.now() - gameStartTime) / 1000;
        const remaining = Math.max(0, gameDuration - elapsed);
        const seconds = Math.floor(remaining);
        let timeColor = remaining <= 10 ? "red" : "#FFFFFF";
        countdownCtx.clearRect(0, 0, countdownCanvas.width, countdownCanvas.height);
        countdownCtx.fillStyle = timeColor;
        countdownCtx.font = 'Bold ' + (64 * resolutionFactor) + 'px Arial';
        countdownCtx.textAlign = "center";
        countdownCtx.textBaseline = "middle";
        countdownCtx.fillText(
          seconds < 10 ? "00:0" + seconds : "00:" + seconds,
          countdownCanvas.width / 2,
          countdownCanvas.height / 2
        );
        countdownTexture.needsUpdate = true;
        if (remaining <= 10 && !beepPlayed) {
          const beepSound = document.getElementById('beepSound');
          beepSound.currentTime = 0;
          beepSound.play().catch((e) => console.error(e));
          beepPlayed = true;
        }
        return remaining;
      }

      function updateScoreDisplay() {
        scoreCtx.clearRect(0, 0, scoreCanvas.width, scoreCanvas.height);
        scoreCtx.fillStyle = "#FFFFFF";
        scoreCtx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        scoreCtx.textAlign = "center";
        scoreCtx.textBaseline = "middle";
        scoreCtx.fillText(`Aciertos: ${correctCount} | Fallos: ${wrongCount}`, scoreCanvas.width / 2, scoreCanvas.height / 2);
        scoreTexture.needsUpdate = true;
      }

      // ------------------ Lógica de juego (preguntas, respuestas, animación) ------------------
      function generateQuestion() {
        const a = Math.floor(Math.random() * 10) + 1;
        const b = Math.floor(Math.random() * 10) + 1;
        correctAnswer = a * b;
        questionText = `¿Cuánto es ${a} x ${b}?`;
        if (questionMesh) {
          scene.remove(questionMesh);
          questionMesh = null;
        }
        updateQuestionPanel();
        updateAnswerObjects();
        beepPlayed = false;
      }

      function updateQuestionPanel() {
        const canvas = document.createElement('canvas');
        canvas.width = 512 * resolutionFactor;
        canvas.height = 128 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.font = 'Bold ' + (48 * resolutionFactor) + 'px Arial';
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        if (questionMesh) {
          questionMesh.material.map = texture;
          questionMesh.material.needsUpdate = true;
        } else {
          const geometry = new THREE.PlaneGeometry(0.6, 0.15);
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
          questionMesh = new THREE.Mesh(geometry, material);
          questionMesh.position.set(0, 0.3, -0.8);
          scene.add(questionMesh);
        }
      }

      function createAnswerObjects(numAnswers, initialCreation) {
        if (initialCreation) {
          const minArc = 1.39626;
          const maxArc = Math.PI;
          let arcAngle;
          if (numAnswers <= 4) {
            arcAngle = minArc;
          } else if (numAnswers >= 10) {
            arcAngle = maxArc;
          } else {
            arcAngle = minArc + ((numAnswers - 4) / (10 - 4)) * (maxArc - minArc);
          }
          const angleStart = -arcAngle / 2;
          const angleEnd = arcAngle / 2;
          const radius = 0.8;
          if (originalAnswerTransforms === null) {
            originalAnswerTransforms = [];
            for (let i = 0; i < numAnswers; i++) {
              const canvas = document.createElement('canvas');
              canvas.width = 256 * resolutionFactor;
              canvas.height = 256 * resolutionFactor;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = "#007BFF";
              drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
              ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
              ctx.fillStyle = "#FFFFFF";
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              const wrongAnswers = new Set();
              while (wrongAnswers.size < numAnswers - 1) {
                let wrong = Math.floor(Math.random() * 100) + 1;
                if (wrong !== correctAnswer) wrongAnswers.add(wrong);
              }
              const answersArray = [correctAnswer, ...wrongAnswers];
              answersArray.sort(() => Math.random() - 0.5);
              ctx.fillText(answersArray[i], canvas.width / 2, canvas.height / 2);
              const texture = new THREE.CanvasTexture(canvas);
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
              const geometry = new THREE.PlaneGeometry(0.15, 0.15);
              const mesh = new THREE.Mesh(geometry, material);
              const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
              const x = radius * Math.sin(angle);
              const z = -radius * Math.cos(angle);
              mesh.position.set(x, 0, z);
              const cameraWorldPos = new THREE.Vector3();
              camera.getWorldPosition(cameraWorldPos);
              const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
              mesh.lookAt(lookAtPos);
              mesh.userData.answer = answersArray[i];
              answers.push(mesh);
              scene.add(mesh);
              originalAnswerTransforms.push({
                position: mesh.position.clone(),
                rotation: mesh.rotation.clone(),
              });
            }
          } else {
            for (let i = 0; i < numAnswers; i++) {
              const canvas = document.createElement('canvas');
              canvas.width = 256 * resolutionFactor;
              canvas.height = 256 * resolutionFactor;
              const ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = "#007BFF";
              drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
              ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
              ctx.fillStyle = "#FFFFFF";
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              const wrongAnswers = new Set();
              while (wrongAnswers.size < numAnswers - 1) {
                let wrong = Math.floor(Math.random() * 100) + 1;
                if (wrong !== correctAnswer) wrongAnswers.add(wrong);
              }
              const answersArray = [correctAnswer, ...wrongAnswers];
              answersArray.sort(() => Math.random() - 0.5);
              ctx.fillText(answersArray[i], canvas.width / 2, canvas.height / 2);
              const texture = new THREE.CanvasTexture(canvas);
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
              const geometry = new THREE.PlaneGeometry(0.15, 0.15);
              const mesh = new THREE.Mesh(geometry, material);
              mesh.position.copy(originalAnswerTransforms[i].position);
              mesh.rotation.copy(originalAnswerTransforms[i].rotation);
              mesh.userData.answer = answersArray[i];
              answers.push(mesh);
              scene.add(mesh);
            }
          }
        } else {
          const numAnswersExisting = selectedNumAnswers;
          const wrongAnswers = new Set();
          while (wrongAnswers.size < numAnswersExisting - 1) {
            let wrong = Math.floor(Math.random() * 100) + 1;
            if (wrong !== correctAnswer) wrongAnswers.add(wrong);
          }
          const answersArray = [correctAnswer, ...wrongAnswers];
          answersArray.sort(() => Math.random() - 0.5);
          for (let i = 0; i < numAnswersExisting; i++) {
            updateAnswerPanel(answers[i], answersArray[i]);
          }
        }
      }

      function updateAnswerPanel(mesh, value) {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 256 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        mesh.material.map = texture;
        mesh.material.transparent = true;
        mesh.material.needsUpdate = true;
        mesh.userData.answer = value;
      }

      // ------------------ Efecto de chispas ------------------
      function createSparksEffect(position) {
        const count = 100;
        const positions = new Float32Array(count * 3);
        const velocities = [];
        for (let i = 0; i < count; i++) {
          positions[i * 3] = position.x;
          positions[i * 3 + 1] = position.y;
          positions[i * 3 + 2] = position.z;
          velocities.push(
            new THREE.Vector3(
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5,
              (Math.random() - 0.5) * 0.5
            )
          );
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        if (!window.sparkTexture) {
          window.sparkTexture = createCircleTexture();
        }
        const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.02,
          map: window.sparkTexture,
          transparent: true,
          depthWrite: false,
        });
        const points = new THREE.Points(geometry, material);
        scene.add(points);
        sparksSystems.push({
          points,
          velocities,
          startTime: performance.now(),
          lastUpdate: performance.now(),
        });
      }

      function createCircleTexture() {
        const size = 128;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
      }

      // ------------------ Animación y render ------------------
      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render(timestamp, xrFrame) {
        renderer.render(scene, camera);

        // Animar paneles de respuesta
        answers.forEach((panel, index) => {
          const baseY = originalAnswerTransforms[index].position.y;
          panel.position.y = baseY + 0.02 * Math.sin(timestamp * 0.005 + index);
        });

        if (gameReady && !countdownStarted) {
          startCountdown();
          const timerSound = document.getElementById('timerSound');
          timerSound.loop = false;
          timerSound.play().catch((e) => console.error(e));
          countdownStarted = true;
        }

        const currentTime = performance.now();
        for (let i = sparksSystems.length - 1; i >= 0; i--) {
          const system = sparksSystems[i];
          const dt = (currentTime - system.lastUpdate) / 1000;
          system.lastUpdate = currentTime;
          const positions = system.points.geometry.attributes.position.array;
          for (let j = 0; j < system.velocities.length; j++) {
            positions[j * 3] += system.velocities[j].x * dt;
            positions[j * 3 + 1] += system.velocities[j].y * dt;
            positions[j * 3 + 2] += system.velocities[j].z * dt;
          }
          system.points.geometry.attributes.position.needsUpdate = true;
          const elapsedTime = currentTime - system.startTime;
          if (elapsedTime > 1700) {
            const fadeProgress = (elapsedTime - 1700) / 300;
            system.points.material.opacity = Math.max(1 - fadeProgress, 0);
          }
          if (elapsedTime > 2000) {
            scene.remove(system.points);
            sparksSystems.splice(i, 1);
          }
        }

        if (!gameOver) {
          const remaining = updateCountdown();
          updateScoreDisplay();
          if (remaining <= 0) {
            endGame();
          }
        }
      }

      // ------------------ Final del juego: crear panel en AR para ingreso de nombre con voz ------------------
      function endGame() {
        gameOver = true;
        if (questionMesh) scene.remove(questionMesh);
        if (countdownMesh) scene.remove(countdownMesh);
        if (scoreMesh) scene.remove(scoreMesh);
        answers.forEach((panel) => scene.remove(panel));
        // Crear panel AR para instrucción de nombre y botones
        createNameInputPanel();
      }

      function createNameInputPanel() {
        // Panel de instrucciones y visualización del nombre
        const canvas = document.createElement('canvas');
        canvas.width = 512 * resolutionFactor;
        canvas.height = 256 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (32 * resolutionFactor) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("Di tu nombre o escríbelo y presiona 🎤", canvas.width/2, canvas.height/2 - 40*resolutionFactor);
        ctx.fillText("Nombre: ", canvas.width/2, canvas.height/2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(1.0, 0.5);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        namePanel = new THREE.Mesh(geometry, material);
        namePanel.position.set(0, 0, -1);
        namePanel.name = "namePanel";
        // Guardamos la referencia al canvas y contexto para actualizar el texto
        namePanel.userData = { canvas, ctx, texture, inputText: "" };
        scene.add(namePanel);

        // Botón de voz
        const voiceButton = createButton("🎤");
        voiceButton.position.set(-0.4, -0.3, -1);
        voiceButton.name = "voiceButton";
        scene.add(voiceButton);
        namePanel.userData.voiceButton = voiceButton;

        // Botón de envío
        const submitButton = createButton("Enviar");
        submitButton.position.set(0.4, -0.3, -1);
        submitButton.name = "submitButton";
        scene.add(submitButton);
        namePanel.userData.submitButton = submitButton;
      }

      // Función para actualizar el panel de nombre con el texto recibido
      function updateNamePanelText() {
        if (!namePanel) return;
        const { canvas, ctx, texture } = namePanel.userData;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (32 * resolutionFactor) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("Di tu nombre o escríbelo y presiona 🎤", canvas.width/2, canvas.height/2 - 40*resolutionFactor);
        ctx.fillText("Nombre: " + namePanel.userData.inputText, canvas.width/2, canvas.height/2);
        texture.needsUpdate = true;
      }

      // ------------------ Funciones Firebase y Leaderboard en AR ------------------
      async function submitScore(playerName, correct, wrong) {
        const leaderboardCollection = "leaderboard_" + selectedNumAnswers;
        try {
          await addDoc(collection(db, leaderboardCollection), {
            name: playerName,
            correct: correct,
            wrong: wrong,
            score: correct - wrong,
            timestamp: Date.now()
          });
          console.log("Puntuación enviada");
          createLeaderboardPanel();
        } catch (e) {
          console.error("Error al enviar la puntuación: ", e);
        }
      }

      async function createLeaderboardPanel() {
        // Elimina el panel de nombre y sus botones
        if(namePanel) {
          if(namePanel.userData.voiceButton) scene.remove(namePanel.userData.voiceButton);
          if(namePanel.userData.submitButton) scene.remove(namePanel.userData.submitButton);
          scene.remove(namePanel);
          namePanel = null;
        }
        // Obtener datos del leaderboard desde Firestore
        const leaderboardCollection = "leaderboard_" + selectedNumAnswers;
        const q = query(collection(db, leaderboardCollection), orderBy("score", "desc"), limit(10));
        const querySnapshot = await getDocs(q);
        // Crear canvas para mostrar la tabla
        const canvas = document.createElement('canvas');
        canvas.width = 512 * resolutionFactor;
        canvas.height = 512 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        let y = 20 * resolutionFactor;
        ctx.fillText("Clasificación - " + selectedNumAnswers + " opciones", 20 * resolutionFactor, y);
        y += 40 * resolutionFactor;
        ctx.fillText("Nombre    Aciertos   Fallos   Resultado", 20 * resolutionFactor, y);
        y += 30 * resolutionFactor;
        querySnapshot.forEach((doc) => {
          const data = doc.data();
          const line = data.name + "   " + data.correct + "   " + data.wrong + "   " + data.score;
          ctx.fillText(line, 20 * resolutionFactor, y);
          y += 30 * resolutionFactor;
        });
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const geometry = new THREE.PlaneGeometry(1.2, 1.2);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        const leaderboardPanel = new THREE.Mesh(geometry, material);
        leaderboardPanel.position.set(0, 0, -1);
        leaderboardPanel.name = "leaderboardPanel";
        scene.add(leaderboardPanel);
        // Botón para reiniciar el juego
        const restartButton = createButton("Reiniciar");
        restartButton.position.set(0, -0.8, -1);
        restartButton.name = "restartButton";
        scene.add(restartButton);
      }

      // ------------------ Web Speech API para voz ------------------
      let recognition;
      if ('webkitSpeechRecognition' in window) {
        recognition = new webkitSpeechRecognition();
      } else if ('SpeechRecognition' in window) {
        recognition = new SpeechRecognition();
      }
      if (recognition) {
        recognition.lang = "es-ES";
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.onresult = function(event) {
          const transcript = event.results[0][0].transcript;
          if(namePanel) {
            namePanel.userData.inputText = transcript;
            updateNamePanelText();
          }
        };
      }

      // ------------------ Eventos de interacción en AR ------------------
      window.addEventListener('touchstart', function(event) {
        const touch = event.touches[0];
        const x = (touch.clientX / window.innerWidth) * 2 - 1;
        const y = -(touch.clientY / window.innerHeight) * 2 + 1;
        const mouseVector = new THREE.Vector2(x, y);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouseVector, camera);
        let objectsToIntersect = [];
        if (gameOver) {
          // Buscar objetos relevantes en estado final: botones de voz, envío o reinicio.
          scene.traverse(child => {
            if(child.name === "voiceButton" || child.name === "submitButton" || child.name === "restartButton") {
              objectsToIntersect.push(child);
            }
          });
        } else {
          objectsToIntersect = answers;
        }
        const intersects = raycaster.intersectObjects(objectsToIntersect);
        if(intersects.length > 0 && !hasCollided) {
          const object = intersects[0].object;
          if(object.name === "voiceButton") {
            if(recognition) recognition.start();
            hasCollided = true;
            setTimeout(()=>{ hasCollided = false; }, 500);
          } else if(object.name === "submitButton") {
            const nameText = namePanel ? namePanel.userData.inputText : "";
            if(nameText) {
              submitScore(nameText, correctCount, wrongCount);
            }
            hasCollided = true;
            setTimeout(()=>{ hasCollided = false; }, 500);
          } else if(object.name === "restartButton") {
            // Eliminar panel de leaderboard y botón reiniciar, y reiniciar el juego.
            scene.traverse(child => {
              if(child.name === "leaderboardPanel" || child.name === "restartButton") {
                scene.remove(child);
              }
            });
            restartGame();
            hasCollided = true;
            setTimeout(()=>{ hasCollided = false; }, 500);
          }
        }
      }, false);

      // ------------------ Reinicio del juego ------------------
      function restartGame() {
        correctCount = 0;
        wrongCount = 0;
        gameStartTime = performance.now();
        gameOver = false;
        answers.forEach((panel) => scene.remove(panel));
        answers = [];
        originalAnswerTransforms = null;
        createAnswerObjects(selectedNumAnswers, true);
        generateQuestion();
        countdownStarted = false;
        gameReady = true;
        createScoreDisplay();
        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime = 0;
        timerSound.loop = false;
        timerSound.play().catch((e) => console.error(e));
      }

      // ------------------ Render y animación ------------------
      init();
      animate();
    </script>
  </body>
</html>
