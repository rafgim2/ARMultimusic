<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>AR MULTIMUSIC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    /* Overlay del menú inicial */
    #overlay {
      position: absolute;
      padding-top: 100px;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: orange;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      color: #fff;
      text-align: center;
      z-index: 10;
    }
    #overlay a {
      font-size: 14px;
      margin-top: -10px;
      margin-bottom: 20px;
      color: blue;
      text-decoration: none;
    }
    #overlay .respuestas-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    #overlay .respuestas-container label {
      font-size: 14px;
      color: black;
    }
    #overlay .respuestas-container select {
      font-size: 14px;
    }
    /* Imagen responsiva */
    #overlay img {
      border-radius: 20px;
      max-width: 15%;
    }
    @media (orientation: portrait) {
      #overlay img {
        max-width: 70%;
      }
    }
  </style>

  <!-- Firebase (versión "compat") -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

  <script>
    // Configuración e inicialización de Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
      authDomain: "arm1-acbba.firebaseapp.com",
      projectId: "arm1-acbba",
      storageBucket: "arm1-acbba.firebasestorage.app",
      messagingSenderId: "408825932019",
      appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
      measurementId: "G-S78TM6PVRL"
    };
    firebase.initializeApp(firebaseConfig);
    firebase.analytics();
    const db = firebase.firestore();
  </script>
</head>

<body>
  <!-- Audios: acierto, error, timer y beep -->
  <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/acierto.wav" preload="auto"></audio>
  <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/error.wav" preload="auto"></audio>
  <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/timer7.mp3" preload="auto"></audio>
  <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let correctAnswer;
    let answers = [];
    let hasCollided = false;
    let questionMesh = null;
    let questionText = "";
    const collisionThreshold = 0.2;
    const sparksSystems = [];

    let correctCount = 0;
    let wrongCount = 0;

    let gameStartTime = 0;
    const gameDuration = 60; // segundos
    let gameOver = false;

    let countdownMesh = null,
        countdownCanvas = null,
        countdownCtx = null,
        countdownTexture = null;
    let scoreMesh = null,
        scoreCanvas = null,
        scoreCtx = null,
        scoreTexture = null;

    let voiceButtonMesh = null;   
    let restartButtonMesh = null; 
    let leaderboardMesh = null;   

    let selectedNumAnswers = 4;

    let originalAnswerTransforms = null;
    let beepPlayed = false;
    let gameReady = false;
    let countdownStarted = false;

    const resolutionFactor = 4;

    // =========================================================
    //             FUNCIONES GRÁFICAS DE APOYO
    // =========================================================

    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }

    function createCircleTexture() {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, size, size);
      return new THREE.CanvasTexture(canvas);
    }

    // =========================================================
    //               INICIALIZACIÓN DE LA ESCENA
    // =========================================================

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      window.addEventListener('resize', onWindowResize, false);

      // Overlay inicial
      const overlay = document.createElement('div');
      overlay.id = 'overlay';
      overlay.innerHTML = `
        <img src="ARM2.jpeg" alt="AR Mult" style="margin-bottom:20px;">
        <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
        <div class="respuestas-container">
          <label for="numAnswers">Respuestas:</label>
          <select id="numAnswers">
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
          </select>
        </div>
      `;

      const isMobile = /Mobi|Android/i.test(navigator.userAgent);
      const requiredFeatures = isMobile ? ['hit-test'] : ['hit-test', 'hand-tracking'];
      const arButton = ARButton.createButton(renderer, { requiredFeatures });
      if (arButton.parentNode) {
        arButton.parentNode.removeChild(arButton);
      }
      arButton.style.position = 'absolute';
      arButton.style.top = '450px';
      arButton.style.left = '100%';
      arButton.style.transform = 'translateX(0%)';
      arButton.style.width = '150px';
      arButton.style.height = '50px';
      arButton.style.fontSize = '16px';
      arButton.style.backgroundColor = 'green';
      arButton.style.color = 'white';
      overlay.appendChild(arButton);

      document.body.appendChild(overlay);

      // Al iniciar la sesión XR
      renderer.xr.addEventListener('sessionstart', () => {
        selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
        createAnswerObjects(selectedNumAnswers, true);
        overlay.remove();
        generateQuestion();
        createScoreDisplay();
        gameReady = true;
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // =========================================================
    //         CONTEO REGRESIVO Y MARCADORES EN PANTALLA
    // =========================================================

    function startCountdown() {
      gameStartTime = performance.now();
      countdownCanvas = document.createElement('canvas');
      countdownCanvas.width = 256 * resolutionFactor;
      countdownCanvas.height = 128 * resolutionFactor;
      countdownCtx = countdownCanvas.getContext('2d');

      countdownTexture = new THREE.CanvasTexture(countdownCanvas);
      countdownTexture.minFilter = THREE.LinearFilter;
      countdownTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.6, 0.3);
      const material = new THREE.MeshBasicMaterial({ map: countdownTexture, transparent: true });
      countdownMesh = new THREE.Mesh(geometry, material);
      countdownMesh.position.set(0, 0.50, -0.82);
      scene.add(countdownMesh);
    }

    function createScoreDisplay() {
      scoreCanvas = document.createElement('canvas');
      scoreCanvas.width = 256 * resolutionFactor;
      scoreCanvas.height = 128 * resolutionFactor;
      scoreCtx = scoreCanvas.getContext('2d');

      scoreTexture = new THREE.CanvasTexture(scoreCanvas);
      scoreTexture.minFilter = THREE.LinearFilter;
      scoreTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.6, 0.3);
      const material = new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true });
      scoreMesh = new THREE.Mesh(geometry, material);
      scoreMesh.position.set(0, -0.2, -0.82);
      scene.add(scoreMesh);
    }

    function updateCountdown() {
      const elapsed = (performance.now() - gameStartTime) / 1000;
      const remaining = Math.max(0, gameDuration - elapsed);
      const seconds = Math.floor(remaining);
      let timeColor = remaining <= 10 ? "red" : "#FFFFFF";
      countdownCtx.clearRect(0, 0, countdownCanvas.width, countdownCanvas.height);

      countdownCtx.fillStyle = timeColor;
      countdownCtx.font = 'Bold ' + (64 * resolutionFactor) + 'px Arial';
      countdownCtx.textAlign = "center";
      countdownCtx.textBaseline = "middle";
      countdownCtx.fillText(
        seconds < 10 ? "00:0" + seconds : "00:" + seconds,
        countdownCanvas.width / 2,
        countdownCanvas.height / 2
      );
      countdownTexture.needsUpdate = true;

      if (remaining <= 10 && !beepPlayed) {
        const beepSound = document.getElementById('beepSound');
        beepSound.currentTime = 0;
        beepSound.play().catch((e) => console.error(e));
        beepPlayed = true;
      }

      return remaining;
    }

    function updateScoreDisplay() {
      scoreCtx.clearRect(0, 0, scoreCanvas.width, scoreCanvas.height);
      scoreCtx.fillStyle = "#FFFFFF";
      scoreCtx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
      scoreCtx.textAlign = "center";
      scoreCtx.textBaseline = "middle";
      scoreCtx.fillText(`Aciertos: ${correctCount} | Fallos: ${wrongCount}`, scoreCanvas.width / 2, scoreCanvas.height / 2);
      scoreTexture.needsUpdate = true;
    }

    // =========================================================
    //            GENERADOR DE PREGUNTAS Y RESPUESTAS
    // =========================================================

    function generateQuestion() {
      const a = Math.floor(Math.random() * 10) + 1;
      const b = Math.floor(Math.random() * 10) + 1;
      correctAnswer = a * b;
      questionText = `¿Cuánto es ${a} x ${b}?`;

      if (questionMesh) {
        scene.remove(questionMesh);
        questionMesh = null;
      }
      updateQuestionPanel();
      updateAnswerObjects();
      beepPlayed = false;
    }

    function updateQuestionPanel() {
      const canvas = document.createElement('canvas');
      canvas.width = 512 * resolutionFactor;
      canvas.height = 128 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      ctx.font = 'Bold ' + (48 * resolutionFactor) + 'px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;

      const geometry = new THREE.PlaneGeometry(0.6, 0.15);
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
      questionMesh = new THREE.Mesh(geometry, material);
      questionMesh.position.set(0, 0.3, -0.8);
      scene.add(questionMesh);
    }

    function createAnswerObjects(numAnswers, initialCreation) {
      if (initialCreation) {
        const minArc = 1.39626; // ~80°
        const maxArc = Math.PI; // 180°
        let arcAngle;
        if (numAnswers <= 4) {
          arcAngle = minArc;
        } else if (numAnswers >= 10) {
          arcAngle = maxArc;
        } else {
          arcAngle = minArc + ((numAnswers - 4) / (10 - 4)) * (maxArc - minArc);
        }
        const angleStart = -arcAngle / 2;
        const angleEnd = arcAngle / 2;
        const radius = 0.8;

        originalAnswerTransforms = [];
        for (let i = 0; i < numAnswers; i++) {
          const mesh = createAnswerPanel("?");
          const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
          const x = radius * Math.sin(angle);
          const z = -radius * Math.cos(angle);
          mesh.position.set(x, 0, z);

          const cameraWorldPos = new THREE.Vector3();
          camera.getWorldPosition(cameraWorldPos);
          const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
          mesh.lookAt(lookAtPos);

          answers.push(mesh);
          scene.add(mesh);

          originalAnswerTransforms.push({
            position: mesh.position.clone(),
            rotation: mesh.rotation.clone(),
          });
        }
      } else {
        // Reutiliza los paneles actualizando el texto
        const wrongAnswers = new Set();
        while (wrongAnswers.size < numAnswers - 1) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random() - 0.5);
        for (let i = 0; i < numAnswers; i++) {
          updateAnswerPanel(answers[i], answersArray[i]);
        }
      }
    }

    function createAnswerPanel(value) {
      const canvas = document.createElement('canvas');
      canvas.width = 256 * resolutionFactor;
      canvas.height = 256 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(value, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
      const geometry = new THREE.PlaneGeometry(0.15, 0.15);

      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData.answer = value;
      return mesh;
    }

    function updateAnswerPanel(mesh, value) {
      const canvas = document.createElement('canvas');
      canvas.width = 256 * resolutionFactor;
      canvas.height = 256 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(value, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      mesh.material.map = texture;
      mesh.material.transparent = true;
      mesh.material.needsUpdate = true;
      mesh.userData.answer = value;
    }

    function updateAnswerObjects() {
      createAnswerObjects(selectedNumAnswers, false);
    }

    // =========================================================
    //                 EFECTO DE CHISPAS
    // =========================================================

    function createSparksEffect(position) {
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      for (let i = 0; i < count; i++) {
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;
        velocities.push(
          new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5
          )
        );
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      if (!window.sparkTexture) {
        window.sparkTexture = createCircleTexture();
      }
      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.02,
        map: window.sparkTexture,
        transparent: true,
        depthWrite: false,
      });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      sparksSystems.push({
        points,
        velocities,
        startTime: performance.now(),
        lastUpdate: performance.now(),
      });
    }

    // =========================================================
    //               BUCLE DE ANIMACIÓN PRINCIPAL
    // =========================================================

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, xrFrame) {
      renderer.render(scene, camera);

      // Efecto de flotación para los paneles de respuesta
      answers.forEach((panel, index) => {
        const baseY = originalAnswerTransforms[index].position.y;
        panel.position.y = baseY + 0.02 * Math.sin(timestamp * 0.005 + index);
      });

      // Iniciar conteo regresivo
      if (gameReady && !countdownStarted) {
        startCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch((e) => console.error(e));
        countdownStarted = true;
      }

      // Actualizar chispas
      const currentTime = performance.now();
      for (let i = sparksSystems.length - 1; i >= 0; i--) {
        const system = sparksSystems[i];
        const dt = (currentTime - system.lastUpdate) / 1000;
        system.lastUpdate = currentTime;
        const positions = system.points.geometry.attributes.position.array;
        for (let j = 0; j < system.velocities.length; j++) {
          positions[j * 3] += system.velocities[j].x * dt;
          positions[j * 3 + 1] += system.velocities[j].y * dt;
          positions[j * 3 + 2] += system.velocities[j].z * dt;
        }
        system.points.geometry.attributes.position.needsUpdate = true;
        const elapsedTime = currentTime - system.startTime;
        if (elapsedTime > 1700) {
          const fadeProgress = (elapsedTime - 1700) / 300;
          system.points.material.opacity = Math.max(1 - fadeProgress, 0);
        }
        if (elapsedTime > 2000) {
          scene.remove(system.points);
          sparksSystems.splice(i, 1);
        }
      }

      // Actualizar tiempo y puntuación
      if (!gameOver) {
        const remaining = updateCountdown();
        updateScoreDisplay();
        if (remaining <= 0) {
          endGame();
        }
      }

      // Sesión XR y puntos de interacción
      const session = renderer.xr.getSession();
      let interactionPoints = [];
      if (session && xrFrame) {
        for (const inputSource of session.inputSources) {
          if (inputSource.hand) {
            const indexTip = inputSource.hand.get('index-finger-tip');
            if (indexTip) {
              const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
              if (jointPose) {
                interactionPoints.push(
                  new THREE.Vector3(
                    jointPose.transform.position.x,
                    jointPose.transform.position.y,
                    jointPose.transform.position.z
                  )
                );
              }
            }
          }
        }
      }
      if (interactionPoints.length === 0) {
        let cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        interactionPoints.push(cameraPos);
      }

      // Lógica de colisión
      if (!gameOver) {
        for (let panel of answers) {
          const panelPos = new THREE.Vector3();
          panel.getWorldPosition(panelPos);
          for (const point of interactionPoints) {
            const distance = point.distanceTo(panelPos);
            if (distance < collisionThreshold && !hasCollided) {
              hasCollided = true;
              if (panel.userData.answer === correctAnswer) {
                correctCount++;
                const successSound = document.getElementById('successSound');
                const successClone = successSound.cloneNode();
                successClone.play().catch((e) => console.error(e));
                createSparksEffect(panel.position);
                if (questionMesh) questionMesh.visible = false;
                answers.forEach((a) => (a.visible = false));
                setTimeout(() => {
                  if (!gameOver) {
                    generateQuestion();
                    if (questionMesh) questionMesh.visible = true;
                    answers.forEach((a) => (a.visible = true));
                  }
                  hasCollided = false;
                }, 1000);
              } else {
                wrongCount++;
                const errorSound = document.getElementById('errorSound');
                const errorClone = errorSound.cloneNode();
                errorClone.play().catch((e) => console.error(e));
                answers.forEach((a) => a.material.color.set(0xff0000));
                setTimeout(() => {
                  answers.forEach((a) => a.material.color.set(0xffffff));
                  hasCollided = false;
                }, 500);
              }
              return;
            }
          }
        }
      } else {
        // Interactuar con "Habla tu nombre" o "Reiniciar"
        if (voiceButtonMesh && voiceButtonMesh.visible) {
          const buttonPos = new THREE.Vector3();
          voiceButtonMesh.getWorldPosition(buttonPos);
          for (const point of interactionPoints) {
            if (point.distanceTo(buttonPos) < collisionThreshold && !hasCollided) {
              hasCollided = true;
              createSparksEffect(voiceButtonMesh.position);
              startVoiceRecognition();
              // Ocultamos el botón tras iniciar la escucha
              setTimeout(() => {
                voiceButtonMesh.visible = false;
                hasCollided = false;
              }, 800);
              break;
            }
          }
        }
        if (restartButtonMesh && restartButtonMesh.visible) {
          const buttonPos = new THREE.Vector3();
          restartButtonMesh.getWorldPosition(buttonPos);
          for (const point of interactionPoints) {
            if (point.distanceTo(buttonPos) < collisionThreshold && !hasCollided) {
              hasCollided = true;
              const successSound = document.getElementById('successSound');
              const successClone = successSound.cloneNode();
              successClone.play().catch((e) => console.error(e));
              createSparksEffect(restartButtonMesh.position);
              restartButtonMesh.visible = false;
              setTimeout(() => {
                restartGame();
                hasCollided = false;
              }, 1000);
              break;
            }
          }
        }
      }
    }

    // =========================================================
    //                    FIN DEL JUEGO
    // =========================================================

    function endGame() {
      gameOver = true;
      if (questionMesh) scene.remove(questionMesh);
      if (countdownMesh) scene.remove(countdownMesh);
      if (scoreMesh) scene.remove(scoreMesh);

      answers.forEach((panel) => scene.remove(panel));
      answers = [];

      // Creamos solo 2 paneles
      voiceButtonMesh = createButton("Habla tu Nombre");
      voiceButtonMesh.position.set(0, 0, -0.8);
      scene.add(voiceButtonMesh);

      restartButtonMesh = createButton("Reiniciar");
      restartButtonMesh.position.set(0, -0.3, -0.8);
      scene.add(restartButtonMesh);
    }

    function createButton(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256 * resolutionFactor;
      canvas.height = 64 * resolutionFactor;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
      ctx.fillStyle = "#FFFFFF";
      ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      const geom = new THREE.PlaneGeometry(0.3, 0.1);
      const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const mesh = new THREE.Mesh(geom, mat);
      return mesh;
    }

    function restartGame() {
      if (leaderboardMesh) {
        scene.remove(leaderboardMesh);
        leaderboardMesh = null;
      }
      if (voiceButtonMesh) scene.remove(voiceButtonMesh);
      if (restartButtonMesh) scene.remove(restartButtonMesh);

      correctCount = 0;
      wrongCount = 0;
      gameOver = false;
      beepPlayed = false;
      countdownStarted = false;

      createAnswerObjects(selectedNumAnswers, true);
      generateQuestion();
      createScoreDisplay();

      const timerSound = document.getElementById('timerSound');
      timerSound.currentTime = 0;
      timerSound.loop = false;
      timerSound.play().catch((e) => console.error(e));

      gameStartTime = performance.now();
      gameReady = true;
    }

    // =========================================================
    //            RECONOCIMIENTO DE VOZ (NOMBRE)
    // =========================================================

    function startVoiceRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert("Este navegador no soporta reconocimiento de voz");
        return;
      }
      const recognition = new SpeechRecognition();
      recognition.lang = "es-ES";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.start();
      recognition.onresult = (event) => {
        let transcript = event.results[0][0].transcript;
        console.log("Reconocido:", transcript);
        submitScoreToFirestore(transcript.trim());
      };
      recognition.onerror = (event) => {
        console.error("Error en reconocimiento de voz:", event.error);
      };
    }

    // =========================================================
    //           FIRESTORE: GUARDAR Y MOSTRAR RANKING
    // =========================================================

    async function submitScoreToFirestore(playerName) {
      try {
        // Guardamos la partida
        await db.collection("leaderboard").add({
          name: playerName,
          correctCount: correctCount,
          wrongCount: wrongCount,
          numAnswers: selectedNumAnswers, // Asegúrate de que sea número
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        console.log("Datos guardados en Firestore");
        // Mostrar la clasificación
        showLeaderboard();
      } catch (error) {
        console.error("Error al guardar en Firestore:", error);
      }
    }

    async function showLeaderboard() {
      // Elimina un ranking anterior si existe
      if (leaderboardMesh) {
        scene.remove(leaderboardMesh);
        leaderboardMesh = null;
      }
      try {
        // Consulta Firestore con where() y orderBy()
        const snapshot = await db.collection("leaderboard")
          .where("numAnswers", "==", selectedNumAnswers)
          .orderBy("correctCount", "desc")
          .limit(10)
          .get();

        console.log("Documentos en la consulta: ", snapshot.size);

        const docs = snapshot.docs;
        let textLines = [];
        textLines.push(`TOP 10 - Respuestas: ${selectedNumAnswers}`);
        textLines.push("Pos | Nombre | Aciertos-Fallos");

        let pos = 1;
        for (let doc of docs) {
          const data = doc.data();
          const line = `${pos}. ${data.name} - ${data.correctCount}-${data.wrongCount}`;
          textLines.push(line);
          pos++;
        }
        if (docs.length === 0) {
          textLines.push("No hay registros todavía");
        }
        // Creamos el panel
        leaderboardMesh = createLeaderboardPanel(textLines);
        // Lo situamos un poco más cerca
        leaderboardMesh.position.set(0, 0.25, -0.8);
        scene.add(leaderboardMesh);
      } catch (error) {
        console.error("Error al obtener leaderboard:", error);
        // Si aquí te pide un índice, ve a la consola y créalo con los campos:
        //   numAnswers (ASC/DESC, da igual en ==) y correctCount (DESC)
      }
    }

    function createLeaderboardPanel(lines) {
      const canvas = document.createElement('canvas');
      canvas.width = 512 * resolutionFactor;
      canvas.height = 512 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);

      ctx.fillStyle = "#FFFFFF";
      ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
      ctx.textAlign = "left";

      let yPos = 40 * resolutionFactor;
      for (let line of lines) {
        ctx.fillText(line, 20 * resolutionFactor, yPos);
        yPos += 40 * resolutionFactor;
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;

      const geom = new THREE.PlaneGeometry(0.8, 0.8);
      const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const mesh = new THREE.Mesh(geom, mat);
      return mesh;
    }

    // =========================================================
    //            EVENTOS TOUCH PARA MÓVILES
    // =========================================================

    window.addEventListener(
      'touchstart',
      function unlockAudio() {
        const successEl = document.getElementById('successSound');
        const errorEl = document.getElementById('errorSound');
        [successEl, errorEl].forEach((audioEl) => {
          audioEl
            .play()
            .then(() => {
              audioEl.pause();
              audioEl.currentTime = 0;
            })
            .catch((e) => console.error(e));
        });
      },
      { once: true }
    );

    window.addEventListener(
      'touchstart',
      function (event) {
        if (!/Mobi|Android/i.test(navigator.userAgent)) return;
        const touch = event.touches[0];
        const x = (touch.clientX / window.innerWidth) * 2 - 1;
        const y = -(touch.clientY / window.innerHeight) * 2 + 1;
        const mouseVector = new THREE.Vector2(x, y);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouseVector, camera);

        if (!gameOver) {
          const intersects = raycaster.intersectObjects(answers);
          if (intersects.length > 0 && !hasCollided) {
            const panel = intersects[0].object;
            hasCollided = true;
            if (panel.userData.answer === correctAnswer) {
              correctCount++;
              const successSound = document.getElementById('successSound');
              const successClone = successSound.cloneNode();
              successClone.play().catch((e) => console.error(e));
              createSparksEffect(panel.position);
              if (questionMesh) questionMesh.visible = false;
              answers.forEach((a) => (a.visible = false));
              setTimeout(() => {
                if (!gameOver) {
                  generateQuestion();
                  if (questionMesh) questionMesh.visible = true;
                  answers.forEach((a) => (a.visible = true));
                }
                hasCollided = false;
              }, 1000);
            } else {
              wrongCount++;
              const errorSound = document.getElementById('errorSound');
              const errorClone = errorSound.cloneNode();
              errorClone.play().catch((e) => console.error(e));
              answers.forEach((a) => a.material.color.set(0xff0000));
              setTimeout(() => {
                answers.forEach((a) => a.material.color.set(0xffffff));
                hasCollided = false;
              }, 500);
            }
          }
        } else {
          let objects = [];
          if (voiceButtonMesh && voiceButtonMesh.visible) objects.push(voiceButtonMesh);
          if (restartButtonMesh && restartButtonMesh.visible) objects.push(restartButtonMesh);

          const intersects = raycaster.intersectObjects(objects);
          if (intersects.length > 0 && !hasCollided) {
            const obj = intersects[0].object;
            hasCollided = true;
            if (obj === voiceButtonMesh) {
              createSparksEffect(obj.position);
              startVoiceRecognition();
              setTimeout(() => {
                voiceButtonMesh.visible = false;
                hasCollided = false;
              }, 800);
            } else if (obj === restartButtonMesh) {
              const successSound = document.getElementById('successSound');
              const successClone = successSound.cloneNode();
              successClone.play().catch((e) => console.error(e));
              createSparksEffect(obj.position);
              obj.visible = false;
              setTimeout(() => {
                restartGame();
                hasCollided = false;
              }, 1000);
            }
          }
        }
      },
      false
    );

    // =========================================================
    //               INICIO DE TODO
    // =========================================================

    init();
    animate();
  </script>
</body>
</html>
