<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>AR MULTIMUSIC / HTML MULTIMUSIC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <style>
      /* Estilos generales */
      body {
        margin: 0;
        font-family: sans-serif;
        overflow-y: auto;
      }
      /* Overlay del menú inicial (igual para ambos modos) */
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        min-height: 100vh;
        background-color: orange;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        text-align: center;
        z-index: 10;
        overflow-y: auto;
        box-sizing: border-box;
        padding: 20px;
      }
      #overlay a {
        font-size: 14px;
        margin-top: 10px;
        margin-bottom: 20px;
        color: blue;
        text-decoration: none;
      }
      /* Contenedor para el selector de respuestas */
      #overlay .respuestas-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      #overlay .respuestas-container label {
        font-size: 14px;
        color: black;
      }
      #overlay .respuestas-container select {
        font-size: 14px;
      }
      /* Imagen */
      #overlay img {
        border-radius: 20px;
        max-width: 15%;
        margin-top: 50px;
        margin-bottom: 10px;
      }
      @media (orientation: portrait) {
        #overlay img {
          max-width: 70%;
        }
      }
      /* Tabla de clasificación en el overlay (igual que antes) */
      #leaderboardPreview {
        max-width: 80%;
        max-height: 120px;
        overflow-y: auto;
        background-color: #fff;
        color: #000;
        font-size: 12px;
        margin-bottom: 20px;
        border: 1px solid #000;
        border-radius: 6px;
        padding: 4px;
      }
      #leaderboardPreview table {
        border-collapse: collapse;
        width: 100%;
      }
      #leaderboardPreview th, #leaderboardPreview td {
        border: 1px solid #666;
        padding: 4px;
        text-align: center;
      }
      #playerName {
        padding: 10px;
        font-size: 16px;
        margin-bottom: 20px;
        box-sizing: border-box;
        width: auto;
      }
      /* Estilos para la versión HTML (modo “tradicional”) */
      #gameContainer {
        position: relative;
        width: 100%;
        height: 100vh;
        background-color: #f0f0f0;
        color: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      button, input {
        -webkit-appearance: none;
        border-radius: 6px;
      }
      /* Estilos para el contenedor HTML (modo “tradicional”) */
      #gameContainer div, #gameContainer button {
        margin-bottom: 20px;
      }
      #gameContainer button {
        font-size: 24px;
        padding: 10px 20px;
      }
      #gameContainer table {
        width: 100%;
        border-collapse: collapse;
      }
      #gameContainer th, #gameContainer td {
        border: 1px solid #666;
        padding: 4px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <!-- Audios: acierto, error, timer (música) y beep -->
    <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/acierto.wav" preload="auto"></audio>
    <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/error.wav" preload="auto"></audio>
    <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/timer7.mp3" preload="auto"></audio>
    <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>

    <script type="module">
      /***** IMPORTACIONES: Firebase, Firestore, Three.js y ARButton *****/
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
      import { 
        getFirestore, collection, addDoc, orderBy, getDocs, serverTimestamp,
        query, where, limit, updateDoc, doc
      } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
      
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';

      /***** CONFIGURACIÓN DE FIREBASE *****/
      const firebaseConfig = {
        apiKey: "AIzaSyD5EAMg-0p54f8bPq8SVdZ_ePg5Xso3cmg",
        authDomain: "arm1-acbba.firebaseapp.com",
        projectId: "arm1-acbba",
        storageBucket: "arm1-acbba.firebasestorage.app",
        messagingSenderId: "408825932019",
        appId: "1:408825932019:web:10f2079b590b4c9ca3af86",
        measurementId: "G-S78TM6PVRL"
      };
      const appFirebase = initializeApp(firebaseConfig);
      const analytics = getAnalytics(appFirebase);
      const db = getFirestore(appFirebase);

      /***** VARIABLES GLOBALES DEL JUEGO (compartidas en AR y HTML) *****/
      let correctAnswer;
      let questionText = "";
      let correctCount = 0;
      let wrongCount = 0;
      let currentQuestionStartTime = 0;
      let correctResponseTimes = [];
      let gameStartTime = 0;
      const gameDuration = 60; // segundos
      let gameOver = false;
      let selectedNumAnswers = 4;
      let playerName = "";

      // Función para generar una nueva pregunta (compartida)
      function generateNewQuestion() {
        const a = Math.floor(Math.random() * 10) + 1;
        const b = Math.floor(Math.random() * 10) + 1;
        correctAnswer = a * b;
        questionText = `¿Cuánto es ${a} x ${b}?`;
        currentQuestionStartTime = performance.now();
      }

      // Función para actualizar la vista previa del leaderboard en el overlay (igual que antes)
      async function updateLeaderboardPreview(numAnswers) {
        const collectionName = `leaderboard_${numAnswers}`;
        try {
          let top5Query = query(
            collection(db, collectionName),
            orderBy("score", "desc"),
            limit(3)
          );
          const querySnapshot = await getDocs(top5Query);
          const results = [];
          querySnapshot.forEach((docSnap) => {
            results.push(docSnap.data());
          });
          const container = document.getElementById('leaderboardPreview');
          container.innerHTML = "";
          if (results.length > 0) {
            let html = "<table>";
            html += "<tr><th>Pos</th><th>Nombre</th><th>Puntos</th></tr>";
            for (let i = 0; i < results.length; i++) {
              html += `<tr>
                <td>${i+1}</td>
                <td>${results[i].name}</td>
                <td>${results[i].score}</td>
              </tr>`;
            }
            html += "</table>";
            container.innerHTML = html;
          } else {
            container.innerHTML = "<p>No hay puntuaciones aún.</p>";
          }
        } catch (err) {
          console.error("Error cargando top 5:", err);
          document.getElementById('leaderboardPreview').innerHTML =
            "<p>Error cargando clasificación.</p>";
        }
      }

      /***** MODO AR *****/
      function initAR() {
        let camera, scene, renderer;
        let questionMesh = null;
        let countdownMesh = null;
        let scoreMesh = null;
        let leaderboardMesh = null;
        let restartButtonMesh = null;
        let scrollUpButtonMesh = null;
        let scrollDownButtonMesh = null;
        let answers = [];
        let hasCollided = false;
        const resolutionFactor = 4;
        const collisionThreshold = 0.3;
        const sparksSystems = [];
        let countdownStarted = false;
        let beepPlayed = false;
        let gameReady = false;
        let initialAnswerTransforms = null;

        function drawRoundedRect(ctx, x, y, width, height, radius) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();
        }
        function createCircleTexture() {
          const size = 128;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const context = canvas.getContext('2d');
          const gradient = context.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
          context.fillStyle = gradient;
          context.fillRect(0, 0, size, size);
          return new THREE.CanvasTexture(canvas);
        }
        function createCanvasPlane(canvas, ctx, width, height) {
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          const geometry = new THREE.PlaneGeometry(width, height);
          const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.userData.canvas = canvas;
          mesh.userData.ctx = ctx;
          mesh.userData.texture = texture;
          return mesh;
        }
        function createButton(text, planeWidth = 0.3, planeHeight = 0.1) {
          const canvas = document.createElement('canvas');
          canvas.width = 256 * resolutionFactor;
          canvas.height = 64 * resolutionFactor;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = "#007BFF";
          drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
          ctx.fillStyle = "#FFFFFF";
          ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          const geom = new THREE.PlaneGeometry(planeWidth, planeHeight);
          const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
          return new THREE.Mesh(geom, mat);
        }
        function updateAnswerPanel(mesh, value) {
          const canvas = document.createElement('canvas');
          canvas.width = 256 * resolutionFactor;
          canvas.height = 256 * resolutionFactor;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#007BFF";
          drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
          ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
          ctx.fillStyle = "#FFFFFF";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(value, canvas.width / 2, canvas.height / 2);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          mesh.material.map = texture;
          mesh.material.transparent = true;
          mesh.material.needsUpdate = true;
          mesh.userData.answer = value;
        }

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        const overlay = document.getElementById('overlay');
        const requiredFeatures = /Mobi|Android/i.test(navigator.userAgent)
          ? ['hit-test']
          : ['hit-test', 'hand-tracking'];
        const arButton = ARButton.createButton(renderer, { requiredFeatures });
        if (arButton.parentNode) {
          arButton.parentNode.removeChild(arButton);
        }
        arButton.style.position = 'absolute';
        arButton.style.top = '600px';
        arButton.style.left = '100%';
        arButton.style.transform = 'translateX(0%)';
        arButton.style.width = '150px';
        arButton.style.height = '50px';
        arButton.style.fontSize = '16px';
        arButton.style.backgroundColor = 'green';
        arButton.style.color = 'white';
        overlay.appendChild(arButton);

        renderer.xr.addEventListener('sessionstart', () => {
          selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
          playerName = document.getElementById('playerName').value.trim() || "Jugador";
          createAnswerObjects(selectedNumAnswers, true);
          overlay.remove();
          generateNewQuestion();
          updateQuestionPanel();
          createScoreDisplay();
          gameReady = true;
        });

        window.addEventListener('touchstart', onTouchStartAR, false);

        window.addEventListener('touchstart', function unlockAudio() {
          const audios = [document.getElementById('successSound'), document.getElementById('errorSound')];
          audios.forEach(audioEl => {
            audioEl.play().then(() => {
              audioEl.pause();
              audioEl.currentTime = 0;
            }).catch(e => console.error(e));
          });
        }, { once: true });

        animate();
      }

      // Función para el modo HTML (sin AR)
      function initHTML() {
        const gameContainer = document.createElement('div');
        gameContainer.id = 'gameContainer';
        document.body.appendChild(gameContainer);
        const questionDiv = document.createElement('div');
        questionDiv.id = 'question';
        questionDiv.style.fontSize = '32px';
        questionDiv.style.marginBottom = '20px';
        gameContainer.appendChild(questionDiv);
        const answersDiv = document.createElement('div');
        answersDiv.id = 'answers';
        answersDiv.style.display = 'flex';
        answersDiv.style.flexWrap = 'wrap';
        answersDiv.style.gap = '10px';
        answersDiv.style.marginBottom = '20px';
        gameContainer.appendChild(answersDiv);
        const countdownDiv = document.createElement('div');
        countdownDiv.id = 'countdown';
        countdownDiv.style.fontSize = '24px';
        countdownDiv.style.marginBottom = '20px';
        gameContainer.appendChild(countdownDiv);
        const scoreDiv = document.createElement('div');
        scoreDiv.id = 'score';
        scoreDiv.style.fontSize = '24px';
        scoreDiv.style.marginBottom = '20px';
        gameContainer.appendChild(scoreDiv);
        const leaderboardDiv = document.createElement('div');
        leaderboardDiv.id = 'leaderboard';
        leaderboardDiv.style.maxWidth = "80%";
        leaderboardDiv.style.maxHeight = "120px";
        leaderboardDiv.style.overflowY = "auto";
        leaderboardDiv.style.backgroundColor = "#fff";
        leaderboardDiv.style.color = "#000";
        leaderboardDiv.style.fontSize = "12px";
        leaderboardDiv.style.marginBottom = "20px";
        leaderboardDiv.style.border = "1px solid #000";
        leaderboardDiv.style.borderRadius = "6px";
        leaderboardDiv.style.padding = "4px";
        gameContainer.appendChild(leaderboardDiv);
        startHTMLGame();
      }
      let htmlCountdownInterval;
      function startHTMLGame() {
        correctCount = 0;
        wrongCount = 0;
        gameOver = false;
        correctResponseTimes = [];
        gameStartTime = performance.now();
        startHTMLCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e => {});
        nextHTMLQuestion();
        updateHTMLScore();
      }
      function nextHTMLQuestion() {
        generateNewQuestion();
        updateHTMLQuestion();
        createHTMLAnswerButtons();
      }
      function updateHTMLQuestion() {
        document.getElementById('question').innerText = questionText;
      }
      function createHTMLAnswerButtons() {
        const answersDiv = document.getElementById('answers');
        answersDiv.innerHTML = '';
        let wrongAnswers = new Set();
        while(wrongAnswers.size < selectedNumAnswers - 1) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random()-0.5);
        answersArray.forEach(ans => {
          const btn = document.createElement('button');
          btn.innerText = ans;
          btn.style.fontSize = '24px';
          btn.style.padding = '10px 20px';
          btn.onclick = () => handleHTMLAnswer(ans, btn);
          answersDiv.appendChild(btn);
        });
      }
      function handleHTMLAnswer(selected, btn) {
        if (gameOver) return;
        if (selected === correctAnswer) {
          btn.style.backgroundColor = "lightgreen";
          let responseTime = performance.now() - currentQuestionStartTime;
          correctResponseTimes.push(responseTime);
          correctCount++;
          updateHTMLScore();
          const successSound = document.getElementById('successSound');
          const successClone = successSound.cloneNode();
          successClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
            nextHTMLQuestion();
          }, 1000);
        } else {
          btn.style.backgroundColor = "red";
          wrongCount++;
          updateHTMLScore();
          const errorSound = document.getElementById('errorSound');
          const errorClone = errorSound.cloneNode();
          errorClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
          }, 500);
        }
      }
      function startHTMLCountdown() {
        if (window.countdownInterval) clearInterval(window.countdownInterval);
        window.countdownInterval = setInterval(()=>{
          const elapsed = (performance.now() - gameStartTime)/1000;
          const remaining = Math.max(0, gameDuration - elapsed);
          document.getElementById('countdown').innerText = `Tiempo: ${Math.floor(remaining)}`;
          if (remaining <= 0) {
            clearInterval(window.countdownInterval);
            endHTMLGame();
          }
        }, 1000);
      }
      function updateHTMLScore() {
        document.getElementById('score').innerText = `Aciertos: ${correctCount} | Fallos: ${wrongCount}`;
      }
      async function endHTMLGame() {
        gameOver = true;
        let avgTime = 0;
        if (correctResponseTimes.length > 0) {
          let sumTimes = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sumTimes / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));
        const collectionName = `leaderboard_${selectedNumAnswers}`;
        let docsFound = await getDocs(query(collection(db, collectionName), where("name", "==", playerName), limit(1)));
        if (!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }
        let qLeaderboard = query(collection(db, collectionName), orderBy("score", "desc"));
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch (err) {
          console.error("Error consultando el leaderboard:", err);
          return;
        }
        let leaderboardResults = [];
        let idx = 0;
        querySnapshot.forEach(docSnap => {
          let data = docSnap.data();
          leaderboardResults.push({ ...data, _index: idx });
          idx++;
        });
        let playerIndex = leaderboardResults.findIndex(r => r.name === playerName && r.score === finalScore);
        let playerPosition = (playerIndex >= 0) ? (playerIndex + 1) : null;
        createLeaderboardMesh();
        drawLeaderboardSegment(leaderboardResults, playerPosition);
      }
      function createLeaderboardMesh() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);
        const dummyCanvas = document.createElement('canvas');
        dummyCanvas.width = 512;
        dummyCanvas.height = 512;
        const ctx = dummyCanvas.getContext('2d');
        const lbTexture = new THREE.CanvasTexture(dummyCanvas);
        lbTexture.minFilter = THREE.LinearFilter;
        lbTexture.magFilter = THREE.LinearFilter;
        const planeWidth = 1.2;
        const planeHeight = 1.0;
        const lbGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const lbMaterial = new THREE.MeshBasicMaterial({ map: lbTexture, transparent: true });
        leaderboardMesh = new THREE.Mesh(lbGeometry, lbMaterial);
        leaderboardMesh.userData = { canvas: dummyCanvas, ctx, texture: lbTexture, planeWidth, planeHeight };
        leaderboardMesh.position.set(0, 0, -1.2);
        scene.add(leaderboardMesh);
        restartButtonMesh = createButton("Reiniciar");
        scene.add(restartButtonMesh);
        scrollUpButtonMesh = createButton("▲", 0.1, 0.1);
        scene.add(scrollUpButtonMesh);
        scrollDownButtonMesh = createButton("▼", 0.1, 0.1);
        scene.add(scrollDownButtonMesh);
      }
      function drawLeaderboardSegment(leaderboardResults, playerPosition) {
        if (!leaderboardMesh) return;
        const { canvas, ctx, texture, planeWidth } = leaderboardMesh.userData;
        const lineHeight = 40 * resolutionFactor;
        const extraLines = 4;
        const canvasWidth = 512 * resolutionFactor;
        const canvasHeight = lineHeight + (leaderboardResults.length + extraLines) * lineHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (28 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`Tabla de Clasificación`, canvasWidth / 2, lineHeight);
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "left";
        let yPos = lineHeight * 2.5;
        leaderboardResults.forEach((data, index) => {
          if (playerPosition !== null && (index+1) === playerPosition) {
            ctx.fillStyle = "green";
          } else {
            ctx.fillStyle = "#FFFFFF";
          }
          ctx.fillText(`${index+1}`, 0.1 * canvasWidth, yPos);
          ctx.fillText(data.name, 0.5 * canvasWidth, yPos);
          ctx.fillText(data.score, 0.9 * canvasWidth, yPos);
          yPos += lineHeight;
        });
        texture.needsUpdate = true;
        const planeHeight = planeWidth * (canvasHeight / canvasWidth);
        leaderboardMesh.geometry.dispose();
        leaderboardMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        leaderboardMesh.position.set(0, 0, -1.2);
        restartButtonMesh.position.set(0, planeHeight/2 + 0.1, -1.1);
        scrollUpButtonMesh.position.set(-planeWidth * 0.5 - 0.1, planeHeight * 0.35, -1.1);
        scrollDownButtonMesh.position.set(-planeWidth * 0.5 - 0.1, -planeHeight * 0.35, -1.1);
      }
      function restartGame() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);
        leaderboardMesh = null;
        restartButtonMesh = null;
        scrollUpButtonMesh = null;
        scrollDownButtonMesh = null;
        correctCount = 0;
        wrongCount = 0;
        gameStartTime = performance.now();
        gameOver = false;
        answers.forEach(panel => scene.remove(panel));
        answers = [];
        createAnswerObjects(selectedNumAnswers, true);
        generateNewQuestion();
        updateQuestionPanel();
        countdownStarted = false;
        gameReady = true;
        createScoreDisplay();
        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime = 0;
        timerSound.loop = false;
        timerSound.play().catch(e => console.error(e));
      }

      /***** MODO HTML *****/
      function initHTML() {
        const gameContainer = document.createElement('div');
        gameContainer.id = 'gameContainer';
        document.body.appendChild(gameContainer);
        const questionDiv = document.createElement('div');
        questionDiv.id = 'question';
        questionDiv.style.fontSize = '32px';
        questionDiv.style.marginBottom = '20px';
        gameContainer.appendChild(questionDiv);
        const answersDiv = document.createElement('div');
        answersDiv.id = 'answers';
        answersDiv.style.display = 'flex';
        answersDiv.style.flexWrap = 'wrap';
        answersDiv.style.gap = '10px';
        answersDiv.style.marginBottom = '20px';
        gameContainer.appendChild(answersDiv);
        const countdownDiv = document.createElement('div');
        countdownDiv.id = 'countdown';
        countdownDiv.style.fontSize = '24px';
        countdownDiv.style.marginBottom = '20px';
        gameContainer.appendChild(countdownDiv);
        const scoreDiv = document.createElement('div');
        scoreDiv.id = 'score';
        scoreDiv.style.fontSize = '24px';
        scoreDiv.style.marginBottom = '20px';
        gameContainer.appendChild(scoreDiv);
        const leaderboardDiv = document.createElement('div');
        leaderboardDiv.id = 'leaderboard';
        leaderboardDiv.style.maxWidth = "80%";
        leaderboardDiv.style.maxHeight = "120px";
        leaderboardDiv.style.overflowY = "auto";
        leaderboardDiv.style.backgroundColor = "#fff";
        leaderboardDiv.style.color = "#000";
        leaderboardDiv.style.fontSize = "12px";
        leaderboardDiv.style.marginBottom = "20px";
        leaderboardDiv.style.border = "1px solid #000";
        leaderboardDiv.style.borderRadius = "6px";
        leaderboardDiv.style.padding = "4px";
        gameContainer.appendChild(leaderboardDiv);
        startHTMLGame();
      }
      let htmlCountdownInterval;
      function startHTMLGame() {
        correctCount = 0;
        wrongCount = 0;
        gameOver = false;
        correctResponseTimes = [];
        gameStartTime = performance.now();
        startHTMLCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e => console.error(e));
        nextHTMLQuestion();
        updateHTMLScore();
      }
      function nextHTMLQuestion() {
        generateNewQuestion();
        updateHTMLQuestion();
        createHTMLAnswerButtons();
      }
      function updateHTMLQuestion() {
        document.getElementById('question').innerText = questionText;
      }
      function createHTMLAnswerButtons() {
        const answersDiv = document.getElementById('answers');
        answersDiv.innerHTML = '';
        let wrongAnswers = new Set();
        while(wrongAnswers.size < selectedNumAnswers - 1) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random() - 0.5);
        answersArray.forEach(ans => {
          const btn = document.createElement('button');
          btn.innerText = ans;
          btn.style.fontSize = '24px';
          btn.style.padding = '10px 20px';
          btn.onclick = () => handleHTMLAnswer(ans, btn);
          answersDiv.appendChild(btn);
        });
      }
      function handleHTMLAnswer(selected, btn) {
        if (gameOver) return;
        if (selected === correctAnswer) {
          btn.style.backgroundColor = "lightgreen";
          let responseTime = performance.now() - currentQuestionStartTime;
          correctResponseTimes.push(responseTime);
          correctCount++;
          updateHTMLScore();
          const successSound = document.getElementById('successSound');
          const successClone = successSound.cloneNode();
          successClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
            nextHTMLQuestion();
          }, 1000);
        } else {
          btn.style.backgroundColor = "red";
          wrongCount++;
          updateHTMLScore();
          const errorSound = document.getElementById('errorSound');
          const errorClone = errorSound.cloneNode();
          errorClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
          }, 500);
        }
      }
      function startHTMLCountdown() {
        if (window.countdownInterval) clearInterval(window.countdownInterval);
        window.countdownInterval = setInterval(()=>{
          const elapsed = (performance.now() - gameStartTime)/1000;
          const remaining = Math.max(0, gameDuration - elapsed);
          document.getElementById('countdown').innerText = `Tiempo: ${Math.floor(remaining)}`;
          if (remaining <= 0) {
            clearInterval(window.countdownInterval);
            endHTMLGame();
          }
        }, 1000);
      }
      function updateHTMLScore() {
        document.getElementById('score').innerText = `Aciertos: ${correctCount} | Fallos: ${wrongCount}`;
      }
      async function endHTMLGame() {
        gameOver = true;
        let avgTime = 0;
        if (correctResponseTimes.length > 0) {
          let sum = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sum / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));
        const collectionName = `leaderboard_${selectedNumAnswers}`;
        let docsFound = await getDocs(query(collection(db, collectionName), where("name", "==", playerName), limit(1)));
        if (!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }
        let qLeaderboard = query(collection(db, collectionName), orderBy("score", "desc"));
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch (err) {
          console.error("Error consultando el leaderboard:", err);
          return;
        }
        let leaderboardResults = [];
        let idx = 0;
        querySnapshot.forEach(docSnap=>{
          let data = docSnap.data();
          leaderboardResults.push({ ...data, _index: idx });
          idx++;
        });
        let playerIndex = leaderboardResults.findIndex(r => r.name === playerName && r.score === finalScore);
        let playerPosition = (playerIndex >= 0) ? (playerIndex + 1) : null;
        createLeaderboardMesh();
        drawLeaderboardSegment(leaderboardResults, playerPosition);
      }
      function createLeaderboardMesh() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);
        const dummyCanvas = document.createElement('canvas');
        dummyCanvas.width = 512;
        dummyCanvas.height = 512;
        const ctx = dummyCanvas.getContext('2d');
        const lbTexture = new THREE.CanvasTexture(dummyCanvas);
        lbTexture.minFilter = THREE.LinearFilter;
        lbTexture.magFilter = THREE.LinearFilter;
        const planeWidth = 1.2;
        const planeHeight = 1.0;
        const lbGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const lbMaterial = new THREE.MeshBasicMaterial({ map: lbTexture, transparent: true });
        leaderboardMesh = new THREE.Mesh(lbGeometry, lbMaterial);
        leaderboardMesh.userData = { canvas: dummyCanvas, ctx, texture: lbTexture, planeWidth, planeHeight };
        leaderboardMesh.position.set(0, 0, -1.2);
        scene.add(leaderboardMesh);
        restartButtonMesh = createButton("Reiniciar");
        scene.add(restartButtonMesh);
        scrollUpButtonMesh = createButton("▲", 0.1, 0.1);
        scene.add(scrollUpButtonMesh);
        scrollDownButtonMesh = createButton("▼", 0.1, 0.1);
        scene.add(scrollDownButtonMesh);
      }
      function drawLeaderboardSegment(leaderboardResults, playerPosition) {
        if (!leaderboardMesh) return;
        const { canvas, ctx, texture, planeWidth } = leaderboardMesh.userData;
        const lineHeight = 40 * resolutionFactor;
        const extraLines = 4;
        const canvasWidth = 512 * resolutionFactor;
        const canvasHeight = lineHeight + (leaderboardResults.length + extraLines) * lineHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (28 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`Tabla de Clasificación`, canvasWidth / 2, lineHeight);
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "left";
        let yPos = lineHeight * 2.5;
        leaderboardResults.forEach((data, index) => {
          if (playerPosition !== null && (index+1) === playerPosition) {
            ctx.fillStyle = "green";
          } else {
            ctx.fillStyle = "#FFFFFF";
          }
          ctx.fillText(`${index+1}`, 0.1 * canvasWidth, yPos);
          ctx.fillText(data.name, 0.5 * canvasWidth, yPos);
          ctx.fillText(data.score, 0.9 * canvasWidth, yPos);
          yPos += lineHeight;
        });
        texture.needsUpdate = true;
        const planeHeight = planeWidth * (canvasHeight / canvasWidth);
        leaderboardMesh.geometry.dispose();
        leaderboardMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        leaderboardMesh.position.set(0, 0, -1.2);
        restartButtonMesh.position.set(0, planeHeight/2 + 0.1, -1.1);
        scrollUpButtonMesh.position.set(-planeWidth * 0.5 - 0.1, planeHeight * 0.35, -1.1);
        scrollDownButtonMesh.position.set(-planeWidth * 0.5 - 0.1, -planeHeight * 0.35, -1.1);
      }
      function restartGame() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);
        leaderboardMesh = null;
        restartButtonMesh = null;
        scrollUpButtonMesh = null;
        scrollDownButtonMesh = null;
        correctCount = 0;
        wrongCount = 0;
        gameStartTime = performance.now();
        gameOver = false;
        answers.forEach(panel => scene.remove(panel));
        answers = [];
        createAnswerObjects(selectedNumAnswers, true);
        generateNewQuestion();
        updateQuestionPanel();
        countdownStarted = false;
        gameReady = true;
        createScoreDisplay();
        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime = 0;
        timerSound.loop = false;
        timerSound.play().catch(e => console.error(e));
      }

      /***** MODO HTML *****/
      function initHTML() {
        const gameContainer = document.createElement('div');
        gameContainer.id = 'gameContainer';
        document.body.appendChild(gameContainer);
        const questionDiv = document.createElement('div');
        questionDiv.id = 'question';
        questionDiv.style.fontSize = '32px';
        questionDiv.style.marginBottom = '20px';
        gameContainer.appendChild(questionDiv);
        const answersDiv = document.createElement('div');
        answersDiv.id = 'answers';
        answersDiv.style.display = 'flex';
        answersDiv.style.flexWrap = 'wrap';
        answersDiv.style.gap = '10px';
        answersDiv.style.marginBottom = '20px';
        gameContainer.appendChild(answersDiv);
        const countdownDiv = document.createElement('div');
        countdownDiv.id = 'countdown';
        countdownDiv.style.fontSize = '24px';
        countdownDiv.style.marginBottom = '20px';
        gameContainer.appendChild(countdownDiv);
        const scoreDiv = document.createElement('div');
        scoreDiv.id = 'score';
        scoreDiv.style.fontSize = '24px';
        scoreDiv.style.marginBottom = '20px';
        gameContainer.appendChild(scoreDiv);
        const leaderboardDiv = document.createElement('div');
        leaderboardDiv.id = 'leaderboard';
        leaderboardDiv.style.maxWidth = "80%";
        leaderboardDiv.style.maxHeight = "120px";
        leaderboardDiv.style.overflowY = "auto";
        leaderboardDiv.style.backgroundColor = "#fff";
        leaderboardDiv.style.color = "#000";
        leaderboardDiv.style.fontSize = "12px";
        leaderboardDiv.style.border = "1px solid #000";
        leaderboardDiv.style.borderRadius = "6px";
        leaderboardDiv.style.padding = "4px";
        gameContainer.appendChild(leaderboardDiv);
        startHTMLGame();
      }
      let htmlCountdownInterval;
      function startHTMLGame() {
        correctCount = 0;
        wrongCount = 0;
        gameOver = false;
        correctResponseTimes = [];
        gameStartTime = performance.now();
        startHTMLCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e => console.error(e));
        nextHTMLQuestion();
        updateHTMLScore();
      }
      function nextHTMLQuestion() {
        generateNewQuestion();
        updateHTMLQuestion();
        createHTMLAnswerButtons();
      }
      function updateHTMLQuestion() {
        document.getElementById('question').innerText = questionText;
      }
      function createHTMLAnswerButtons() {
        const answersDiv = document.getElementById('answers');
        answersDiv.innerHTML = '';
        let wrongAnswers = new Set();
        while(wrongAnswers.size < selectedNumAnswers - 1) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random()-0.5);
        answersArray.forEach(ans => {
          const btn = document.createElement('button');
          btn.innerText = ans;
          btn.style.fontSize = '24px';
          btn.style.padding = '10px 20px';
          btn.onclick = () => handleHTMLAnswer(ans, btn);
          answersDiv.appendChild(btn);
        });
      }
      function handleHTMLAnswer(selected, btn) {
        if (gameOver) return;
        if (selected === correctAnswer) {
          btn.style.backgroundColor = "lightgreen";
          let responseTime = performance.now() - currentQuestionStartTime;
          correctResponseTimes.push(responseTime);
          correctCount++;
          updateHTMLScore();
          const successSound = document.getElementById('successSound');
          const successClone = successSound.cloneNode();
          successClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
            nextHTMLQuestion();
          }, 1000);
        } else {
          btn.style.backgroundColor = "red";
          wrongCount++;
          updateHTMLScore();
          const errorSound = document.getElementById('errorSound');
          const errorClone = errorSound.cloneNode();
          errorClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
          }, 500);
        }
      }
      function startHTMLCountdown() {
        if(window.countdownInterval) clearInterval(window.countdownInterval);
        window.countdownInterval = setInterval(()=>{
          const elapsed = (performance.now() - gameStartTime)/1000;
          const remaining = Math.max(0, gameDuration - elapsed);
          document.getElementById('countdown').innerText = `Tiempo: ${Math.floor(remaining)}`;
          if(remaining <= 0) {
            clearInterval(window.countdownInterval);
            endHTMLGame();
          }
        }, 1000);
      }
      function updateHTMLScore() {
        document.getElementById('score').innerText = `Aciertos: ${correctCount} | Fallos: ${wrongCount}`;
      }
      async function endHTMLGame() {
        gameOver = true;
        let avgTime = 0;
        if(correctResponseTimes.length > 0) {
          let sum = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sum / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));
        const collectionName = `leaderboard_${selectedNumAnswers}`;
        let docsFound = await getDocs(query(collection(db, collectionName), where("name", "==", playerName), limit(1)));
        if(!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }
        let qLeaderboard = query(collection(db, collectionName), orderBy("score", "desc"));
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch(err) {
          console.error("Error consultando leaderboard:", err);
          return;
        }
        let leaderboardResults = [];
        let idx = 0;
        querySnapshot.forEach(docSnap=>{
          let data = docSnap.data();
          leaderboardResults.push({ ...data, _index: idx });
          idx++;
        });
        let playerIndex = leaderboardResults.findIndex(r=> r.name===playerName && r.score===finalScore);
        let playerPosition = (playerIndex>=0)? (playerIndex+1) : null;
        createLeaderboardMesh();
        drawLeaderboardSegment(leaderboardResults, playerPosition);
      }
      function createLeaderboardMesh() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);
        const dummyCanvas = document.createElement('canvas');
        dummyCanvas.width = 512;
        dummyCanvas.height = 512;
        const ctx = dummyCanvas.getContext('2d');
        const lbTexture = new THREE.CanvasTexture(dummyCanvas);
        lbTexture.minFilter = THREE.LinearFilter;
        lbTexture.magFilter = THREE.LinearFilter;
        const planeWidth = 1.2;
        const planeHeight = 1.0;
        const lbGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const lbMaterial = new THREE.MeshBasicMaterial({ map: lbTexture, transparent: true });
        leaderboardMesh = new THREE.Mesh(lbGeometry, lbMaterial);
        leaderboardMesh.userData = { canvas: dummyCanvas, ctx, texture: lbTexture, planeWidth, planeHeight };
        leaderboardMesh.position.set(0, 0, -1.2);
        scene.add(leaderboardMesh);
        restartButtonMesh = createButton("Reiniciar");
        scene.add(restartButtonMesh);
        scrollUpButtonMesh = createButton("▲", 0.1, 0.1);
        scene.add(scrollUpButtonMesh);
        scrollDownButtonMesh = createButton("▼", 0.1, 0.1);
        scene.add(scrollDownButtonMesh);
      }
      function drawLeaderboardSegment(leaderboardResults, playerPosition) {
        if (!leaderboardMesh) return;
        const { canvas, ctx, texture, planeWidth } = leaderboardMesh.userData;
        const lineHeight = 40 * resolutionFactor;
        const extraLines = 4;
        const canvasWidth = 512 * resolutionFactor;
        const canvasHeight = lineHeight + (leaderboardResults.length + extraLines) * lineHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = 'Bold ' + (28 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`Tabla de Clasificación`, canvasWidth / 2, lineHeight);
        ctx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
        ctx.textAlign = "left";
        let yPos = lineHeight * 2.5;
        leaderboardResults.forEach((data, index) => {
          if (playerPosition !== null && (index+1) === playerPosition) {
            ctx.fillStyle = "green";
          } else {
            ctx.fillStyle = "#FFFFFF";
          }
          ctx.fillText(`${index+1}`, 0.1 * canvasWidth, yPos);
          ctx.fillText(data.name, 0.5 * canvasWidth, yPos);
          ctx.fillText(data.score, 0.9 * canvasWidth, yPos);
          yPos += lineHeight;
        });
        texture.needsUpdate = true;
        const planeHeight = planeWidth * (canvasHeight / canvasWidth);
        leaderboardMesh.geometry.dispose();
        leaderboardMesh.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        leaderboardMesh.position.set(0, 0, -1.2);
        restartButtonMesh.position.set(0, planeHeight/2 + 0.1, -1.1);
        scrollUpButtonMesh.position.set(-planeWidth * 0.5 - 0.1, planeHeight * 0.35, -1.1);
        scrollDownButtonMesh.position.set(-planeWidth * 0.5 - 0.1, -planeHeight * 0.35, -1.1);
      }
      function restartGame() {
        if (leaderboardMesh) scene.remove(leaderboardMesh);
        if (restartButtonMesh) scene.remove(restartButtonMesh);
        if (scrollUpButtonMesh) scene.remove(scrollUpButtonMesh);
        if (scrollDownButtonMesh) scene.remove(scrollDownButtonMesh);
        leaderboardMesh = null;
        restartButtonMesh = null;
        scrollUpButtonMesh = null;
        scrollDownButtonMesh = null;
        correctCount = 0;
        wrongCount = 0;
        gameStartTime = performance.now();
        gameOver = false;
        answers.forEach(panel => scene.remove(panel));
        answers = [];
        createAnswerObjects(selectedNumAnswers, true);
        generateNewQuestion();
        updateQuestionPanel();
        countdownStarted = false;
        gameReady = true;
        createScoreDisplay();
        const timerSound = document.getElementById('timerSound');
        timerSound.currentTime = 0;
        timerSound.loop = false;
        timerSound.play().catch(e => console.error(e));
      }

      /***** MODO HTML *****/
      function initHTML() {
        const gameContainer = document.createElement('div');
        gameContainer.id = 'gameContainer';
        document.body.appendChild(gameContainer);
        const questionDiv = document.createElement('div');
        questionDiv.id = 'question';
        questionDiv.style.fontSize = '32px';
        questionDiv.style.marginBottom = '20px';
        gameContainer.appendChild(questionDiv);
        const answersDiv = document.createElement('div');
        answersDiv.id = 'answers';
        answersDiv.style.display = 'flex';
        answersDiv.style.flexWrap = 'wrap';
        answersDiv.style.gap = '10px';
        answersDiv.style.marginBottom = '20px';
        gameContainer.appendChild(answersDiv);
        const countdownDiv = document.createElement('div');
        countdownDiv.id = 'countdown';
        countdownDiv.style.fontSize = '24px';
        countdownDiv.style.marginBottom = '20px';
        gameContainer.appendChild(countdownDiv);
        const scoreDiv = document.createElement('div');
        scoreDiv.id = 'score';
        scoreDiv.style.fontSize = '24px';
        scoreDiv.style.marginBottom = '20px';
        gameContainer.appendChild(scoreDiv);
        const leaderboardDiv = document.createElement('div');
        leaderboardDiv.id = 'leaderboard';
        leaderboardDiv.style.maxWidth = "80%";
        leaderboardDiv.style.maxHeight = "120px";
        leaderboardDiv.style.overflowY = "auto";
        leaderboardDiv.style.backgroundColor = "#fff";
        leaderboardDiv.style.color = "#000";
        leaderboardDiv.style.fontSize = "12px";
        leaderboardDiv.style.border = "1px solid #000";
        leaderboardDiv.style.borderRadius = "6px";
        leaderboardDiv.style.padding = "4px";
        gameContainer.appendChild(leaderboardDiv);
        startHTMLGame();
      }
      let htmlCountdownInterval;
      function startHTMLGame() {
        correctCount = 0;
        wrongCount = 0;
        gameOver = false;
        correctResponseTimes = [];
        gameStartTime = performance.now();
        startHTMLCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e => {});
        nextHTMLQuestion();
        updateHTMLScore();
      }
      function nextHTMLQuestion() {
        generateNewQuestion();
        updateHTMLQuestion();
        createHTMLAnswerButtons();
      }
      function updateHTMLQuestion() {
        document.getElementById('question').innerText = questionText;
      }
      function createHTMLAnswerButtons() {
        const answersDiv = document.getElementById('answers');
        answersDiv.innerHTML = '';
        let wrongAnswers = new Set();
        while(wrongAnswers.size < selectedNumAnswers - 1) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random()-0.5);
        answersArray.forEach(ans => {
          const btn = document.createElement('button');
          btn.innerText = ans;
          btn.style.fontSize = '24px';
          btn.style.padding = '10px 20px';
          btn.onclick = () => handleHTMLAnswer(ans, btn);
          answersDiv.appendChild(btn);
        });
      }
      function handleHTMLAnswer(selected, btn) {
        if (gameOver) return;
        if (selected === correctAnswer) {
          btn.style.backgroundColor = "lightgreen";
          let responseTime = performance.now() - currentQuestionStartTime;
          correctResponseTimes.push(responseTime);
          correctCount++;
          updateHTMLScore();
          const successSound = document.getElementById('successSound');
          const successClone = successSound.cloneNode();
          successClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
            nextHTMLQuestion();
          }, 1000);
        } else {
          btn.style.backgroundColor = "red";
          wrongCount++;
          updateHTMLScore();
          const errorSound = document.getElementById('errorSound');
          const errorClone = errorSound.cloneNode();
          errorClone.play().catch(e => console.error(e));
          setTimeout(() => {
            btn.style.backgroundColor = "";
          }, 500);
        }
      }
      function startHTMLCountdown() {
        if(window.countdownInterval) clearInterval(window.countdownInterval);
        window.countdownInterval = setInterval(()=>{
          const elapsed = (performance.now() - gameStartTime)/1000;
          const remaining = Math.max(0, gameDuration - elapsed);
          document.getElementById('countdown').innerText = `Tiempo: ${Math.floor(remaining)}`;
          if(remaining <= 0) {
            clearInterval(window.countdownInterval);
            endHTMLGame();
          }
        }, 1000);
      }
      function updateHTMLScore() {
        document.getElementById('score').innerText = `Aciertos: ${correctCount} | Fallos: ${wrongCount}`;
      }
      async function endHTMLGame() {
        gameOver = true;
        let avgTime = 0;
        if(correctResponseTimes.length > 0) {
          let sum = correctResponseTimes.reduce((acc, t) => acc + t, 0);
          avgTime = sum / correctResponseTimes.length / 1000;
        }
        const rawScore = (correctCount - wrongCount) - avgTime;
        const finalScore = parseFloat(rawScore.toFixed(3));
        const collectionName = `leaderboard_${selectedNumAnswers}`;
        let docsFound = await getDocs(query(collection(db, collectionName), where("name", "==", playerName), limit(1)));
        if(!docsFound.empty) {
          const docToUpdate = docsFound.docs[0];
          await updateDoc(doc(db, collectionName, docToUpdate.id), {
            score: finalScore,
            timestamp: serverTimestamp()
          });
        } else {
          await addDoc(collection(db, collectionName), {
            name: playerName,
            score: finalScore,
            timestamp: serverTimestamp()
          });
        }
        let qLeaderboard = query(collection(db, collectionName), orderBy("score", "desc"));
        let querySnapshot;
        try {
          querySnapshot = await getDocs(qLeaderboard);
        } catch(err) {
          console.error("Error consultando leaderboard:", err);
          return;
        }
        let results = [];
        let idx = 0;
        querySnapshot.forEach(docSnap=>{
          let data = docSnap.data();
          results.push({ ...data, _index: idx });
          idx++;
        });
        displayHTMLLeaderboard(results, finalScore);
        const gameContainer = document.getElementById('gameContainer');
        const restartBtn = document.createElement('button');
        restartBtn.innerText = "Reiniciar";
        restartBtn.style.fontSize = '24px';
        restartBtn.style.padding = '10px 20px';
        restartBtn.onclick = ()=>{
          restartBtn.remove();
          document.getElementById('leaderboard').innerHTML = '';
          document.getElementById('question').innerText = '';
          document.getElementById('answers').innerHTML = '';
          startHTMLGame();
        };
        gameContainer.appendChild(restartBtn);
      }
      function displayHTMLLeaderboard(leaderboardResults, finalScore) {
        const leaderboardDiv = document.getElementById('leaderboard');
        leaderboardDiv.innerHTML = '';
        const table = document.createElement('table');
        const headerRow = document.createElement('tr');
        ['Pos', 'Nombre', 'Puntos'].forEach(header=>{
          const th = document.createElement('th');
          th.innerText = header;
          headerRow.appendChild(th);
        });
        table.appendChild(headerRow);
        leaderboardResults.forEach((data, index)=>{
          const row = document.createElement('tr');
          if(data.name === playerName && data.score === finalScore) {
            row.style.backgroundColor = 'green';
            row.style.color = '#fff';
          }
          const posCell = document.createElement('td');
          posCell.innerText = index+1;
          const nameCell = document.createElement('td');
          nameCell.innerText = data.name;
          const scoreCell = document.createElement('td');
          scoreCell.innerText = data.score;
          row.appendChild(posCell);
          row.appendChild(nameCell);
          row.appendChild(scoreCell);
          table.appendChild(row);
        });
        leaderboardDiv.appendChild(table);
      }

      /***** FALLBACK: Si no se puede iniciar AR, se muestra el overlay para HTML *****/
      function fallbackToHTML() {
        const overlay = document.createElement('div');
        overlay.id = 'overlay';
        overlay.innerHTML = `
          <img src="ARM2.jpeg" alt="AR Mult" style="margin-bottom:20px;">
          <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
          <div class="respuestas-container">
            <label for="numAnswers">Respuestas:</label>
            <select id="numAnswers">
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </div>
          <div id="leaderboardPreview"></div>
          <input type="text" id="playerName" placeholder="Ingresa tu nombre" maxlength="10" style="padding:10px; font-size:16px; margin-bottom:20px;">
        `;
        document.body.appendChild(overlay);
        document.getElementById('numAnswers').addEventListener('change', () => {
          const num = parseInt(document.getElementById('numAnswers').value) || 4;
          updateLeaderboardPreview(num);
        });
        updateLeaderboardPreview(4);
        selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
        playerName = document.getElementById('playerName').value.trim() || "Jugador";
        const startBtn = document.createElement('button');
        startBtn.style.fontSize = '16px';
        startBtn.style.padding = '10px 20px';
        startBtn.style.marginTop = '20px';
        startBtn.innerText = "AR no compatible, Iniciar Juego HTML";
        startBtn.onclick = () => {
          playerName = document.getElementById('playerName').value.trim() || "Jugador";
          overlay.remove();
          initHTML();
        };
        overlay.appendChild(startBtn);
      }

      /***** INICIALIZACIÓN COMÚN: Overlay y elección de modo *****/
      window.addEventListener('DOMContentLoaded', async () => {
        const overlay = document.createElement('div');
        overlay.id = 'overlay';
        overlay.innerHTML = `
          <img src="ARM2.jpeg" alt="AR Mult">
          <a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>
          <div class="respuestas-container">
            <label for="numAnswers">Respuestas:</label>
            <select id="numAnswers">
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </div>
          <div id="leaderboardPreview"></div>
          <input type="text" id="playerName" placeholder="Ingresa tu nombre" maxlength="10">
        `;
        document.body.appendChild(overlay);
        document.getElementById('numAnswers').addEventListener('change', () => {
          const num = parseInt(document.getElementById('numAnswers').value) || 4;
          updateLeaderboardPreview(num);
        });
        updateLeaderboardPreview(4);
        selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
        playerName = document.getElementById('playerName').value.trim() || "Jugador";
        if (navigator.xr) {
          try {
            const supported = await navigator.xr.isSessionSupported('immersive-ar');
            if (supported) {
              // Intentamos iniciar la sesión AR
              navigator.xr.requestSession('immersive-ar').then((session) => {
                renderer.xr.setSession(session);
                initAR();
              }).catch((err) => {
                console.error("Error iniciando sesión AR:", err);
                fallbackToHTML();
              });
            } else {
              fallbackToHTML();
            }
          } catch(e) {
            fallbackToHTML();
          }
        } else {
          fallbackToHTML();
        }
        window.addEventListener('touchstart', function unlockAudio() {
          const audios = [document.getElementById('successSound'), document.getElementById('errorSound')];
          audios.forEach(audioEl=>{
            audioEl.play().then(()=>{
              audioEl.pause();
              audioEl.currentTime = 0;
            }).catch(e=>console.error(e));
          });
        }, { once: true });
      });
    </script>
  </body>
</html>
