<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>AR MULTIMUSIC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    /* Overlay del menú inicial (HTML) */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      text-align: center;
      z-index: 10;
    }
    #overlay h1 {
      font-size: 48px;
      margin-bottom: 20px;
    }
    #overlay label, #overlay select {
      font-size: 24px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <!-- Audios: acierto, error y timer (fondo, sin loop) -->
  <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/acierto.wav" preload="auto"></audio>
  <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/error.wav" preload="auto"></audio>
  <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/timer.wav" preload="auto"></audio>
  
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
    // Si no es móvil, se solicita "hand-tracking" además de "hit-test"
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const requiredFeatures = isMobile ? ['hit-test'] : ['hit-test', 'hand-tracking'];
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';
    
    let camera, scene, renderer;
    let correctAnswer;
    let answers = []; // Paneles de respuesta (creados una sola vez)
    let hasCollided = false;
    let questionMesh = null;
    let questionText = "";
    const collisionThreshold = 0.2;
    const sparksSystems = [];
    
    // Contadores
    let correctCount = 0;
    let wrongCount = 0;
    
    // Tiempo de juego
    let gameStartTime = 0;
    const gameDuration = 60; // segundos
    let gameOver = false;
    
    // Mallas AR para cuenta atrás y score
    let countdownMesh = null, countdownCanvas = null, countdownCtx = null, countdownTexture = null;
    let scoreMesh = null, scoreCanvas = null, scoreCtx = null, scoreTexture = null;
    
    // Variables para la pantalla final en AR
    let finalScreenMeshes = []; // Array para los botones y resumen final
    
    // Número de respuestas seleccionado (global)
    let selectedNumAnswers = 4;
    
    // Función para dibujar un rectángulo redondeado (estilo de respuestas)
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    
    // Actualiza la textura de un panel de respuesta según su valor
    function updateAnswerPanel(mesh, value) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20);
      ctx.shadowBlur = 0;
      ctx.font = 'Bold 75px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(value, canvas.width / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      mesh.material.map = texture;
      mesh.material.needsUpdate = true;
      mesh.userData.answer = value;
    }
    
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);
      
      window.addEventListener('resize', onWindowResize, false);
      
      // Overlay inicial (HTML)
      const overlay = document.createElement('div');
      overlay.id = 'overlay';
      overlay.innerHTML =
        '<h1>AR MULTIMUSIC</h1>' +
        '<label for="numAnswers">Número de respuestas:</label>' +
        '<select id="numAnswers">' +
          '<option value="4">4</option>' +
          '<option value="5">5</option>' +
          '<option value="6">6</option>' +
          '<option value="7">7</option>' +
          '<option value="8">8</option>' +
          '<option value="9">9</option>' +
          '<option value="10">10</option>' +
        '</select>';
      const arButton = ARButton.createButton(renderer, { requiredFeatures });
      overlay.appendChild(arButton);
      document.body.appendChild(overlay);
      
      renderer.xr.addEventListener('sessionstart', () => {
        const sel = document.getElementById('numAnswers');
        selectedNumAnswers = sel ? parseInt(sel.value) : 4;
        createAnswerObjects(selectedNumAnswers, true); // Crear paneles (posición fija)
        overlay.remove();
        generateQuestion();
        startCountdown();
        createScoreDisplay();
        // Reproducir sonido de fondo "timer" (una sola vez)
        const timerSound = document.getElementById('timerSound');
        timerSound.play().catch(e => console.error(e));
      });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Malla para la pregunta: (0, 0.3, -0.8)
    function updateQuestionPanel() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20);
      ctx.shadowBlur = 0;
      ctx.font = 'Bold 48px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      if (questionMesh) {
        questionMesh.material.map = texture;
        questionMesh.material.needsUpdate = true;
      } else {
        const geometry = new THREE.PlaneGeometry(0.6, 0.15);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        questionMesh = new THREE.Mesh(geometry, material);
        questionMesh.position.set(0, 0.3, -0.8);
        scene.add(questionMesh);
      }
    }
    
    // Muestra los paneles de respuesta. Si initialCreation es true, se calculan sus posiciones y se crean; de lo contrario, solo se actualizan los valores.
    function createAnswerObjects(numAnswers, initialCreation) {
      if (initialCreation) {
        const minArc = Math.PI / 3;
        const maxArc = Math.PI;
        let arcAngle = (numAnswers <= 4) ? minArc : (numAnswers >= 10 ? maxArc : minArc + ((numAnswers - 4) / (10 - 4)) * (maxArc - minArc));
        const angleStart = -arcAngle / 2;
        const angleEnd = arcAngle / 2;
        const radius = 0.8;
        
        const wrongAnswers = new Set();
        while (wrongAnswers.size < (numAnswers - 1)) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random() - 0.5);
        
        for (let i = 0; i < numAnswers; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.shadowColor = "rgba(0,0,0,0.5)";
          ctx.shadowBlur = 10;
          ctx.fillStyle = "#007BFF";
          drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20);
          ctx.shadowBlur = 0;
          ctx.font = 'Bold 75px Arial';
          ctx.fillStyle = "#FFFFFF";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(answersArray[i], canvas.width / 2, canvas.height / 2);
          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
          const geometry = new THREE.PlaneGeometry(0.15, 0.15);
          const mesh = new THREE.Mesh(geometry, material);
          const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
          const x = radius * Math.sin(angle);
          const z = -radius * Math.cos(angle);
          mesh.position.set(x, 0, z);
          const cameraWorldPos = new THREE.Vector3();
          camera.getWorldPosition(cameraWorldPos);
          const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
          mesh.lookAt(lookAtPos);
          mesh.userData.answer = answersArray[i];
          answers.push(mesh);
          scene.add(mesh);
        }
      } else {
        const numAnswersExisting = selectedNumAnswers;
        const wrongAnswers = new Set();
        while (wrongAnswers.size < (numAnswersExisting - 1)) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random() - 0.5);
        for (let i = 0; i < numAnswersExisting; i++) {
          updateAnswerPanel(answers[i], answersArray[i]);
        }
      }
    }
    
    function updateAnswerObjects() {
      createAnswerObjects(selectedNumAnswers, false);
    }
    
    function createSparksEffect(position) {
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      for (let i = 0; i < count; i++) {
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;
        velocities.push(new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ));
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.02 });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      sparksSystems.push({
        points,
        velocities,
        startTime: performance.now(),
        lastUpdate: performance.now()
      });
    }
    
    // Variables para la pantalla final en AR
    let finalScreenCreated = false;
    let finalSummaryMesh = null;
    let restartButtonMesh = null;
    let exitButtonMesh = null;
    
    // Crea la pantalla final en AR con resumen y botones interactivos
    function createFinalScreen() {
      // Resumen final (recuadro azul similar a las respuestas)
      const summaryCanvas = document.createElement('canvas');
      summaryCanvas.width = 512;
      summaryCanvas.height = 256;
      const summaryCtx = summaryCanvas.getContext('2d');
      summaryCtx.fillStyle = "#007BFF";
      drawRoundedRect(summaryCtx, 0, 0, summaryCanvas.width, summaryCanvas.height, 20);
      summaryCtx.fillStyle = "#FFFFFF";
      summaryCtx.font = "Bold 48px Arial";
      summaryCtx.textAlign = "center";
      summaryCtx.textBaseline = "middle";
      summaryCtx.fillText("Fin del Juego", summaryCanvas.width / 2, 60);
      summaryCtx.font = "Bold 36px Arial";
      summaryCtx.fillText(`Aciertos: ${correctCount}`, summaryCanvas.width / 2, 130);
      summaryCtx.fillText(`Fallos: ${wrongCount}`, summaryCanvas.width / 2, 190);
      const summaryTexture = new THREE.CanvasTexture(summaryCanvas);
      const summaryGeom = new THREE.PlaneGeometry(1.0, 0.5);
      const summaryMat = new THREE.MeshBasicMaterial({ map: summaryTexture, transparent: true });
      finalSummaryMesh = new THREE.Mesh(summaryGeom, summaryMat);
      finalSummaryMesh.position.set(0, 0, -1);
      scene.add(finalSummaryMesh);
      
      // Botón "Reiniciar"
      const restartCanvas = document.createElement('canvas');
      restartCanvas.width = 256;
      restartCanvas.height = 128;
      const restartCtx = restartCanvas.getContext('2d');
      restartCtx.fillStyle = "#007BFF";
      drawRoundedRect(restartCtx, 0, 0, restartCanvas.width, restartCanvas.height, 20);
      restartCtx.fillStyle = "#FFFFFF";
      restartCtx.font = "Bold 36px Arial";
      restartCtx.textAlign = "center";
      restartCtx.textBaseline = "middle";
      restartCtx.fillText("Reiniciar", restartCanvas.width / 2, restartCanvas.height / 2);
      const restartTexture = new THREE.CanvasTexture(restartCanvas);
      const restartGeom = new THREE.PlaneGeometry(0.4, 0.2);
      const restartMat = new THREE.MeshBasicMaterial({ map: restartTexture, transparent: true });
      restartButtonMesh = new THREE.Mesh(restartGeom, restartMat);
      restartButtonMesh.position.set(-0.3, -0.4, -1);
      scene.add(restartButtonMesh);
      
      // Botón "Salir"
      const exitCanvas = document.createElement('canvas');
      exitCanvas.width = 256;
      exitCanvas.height = 128;
      const exitCtx = exitCanvas.getContext('2d');
      exitCtx.fillStyle = "#007BFF";
      drawRoundedRect(exitCtx, 0, 0, exitCanvas.width, exitCanvas.height, 20);
      exitCtx.fillStyle = "#FFFFFF";
      exitCtx.font = "Bold 36px Arial";
      exitCtx.textAlign = "center";
      exitCtx.textBaseline = "middle";
      exitCtx.fillText("Salir", exitCanvas.width / 2, exitCanvas.height / 2);
      const exitTexture = new THREE.CanvasTexture(exitCanvas);
      const exitGeom = new THREE.PlaneGeometry(0.4, 0.2);
      const exitMat = new THREE.MeshBasicMaterial({ map: exitTexture, transparent: true });
      exitButtonMesh = new THREE.Mesh(exitGeom, exitMat);
      exitButtonMesh.position.set(0.3, -0.4, -1);
      scene.add(exitButtonMesh);
      
      finalScreenCreated = true;
    }
    
    function animate() {
      renderer.setAnimationLoop(render);
    }
    
    function render(timestamp, xrFrame) {
      renderer.render(scene, camera);
      
      const currentTime = performance.now();
      // Actualizar partículas
      for (let i = sparksSystems.length - 1; i >= 0; i--) {
        const system = sparksSystems[i];
        const dt = (currentTime - system.lastUpdate) / 1000;
        system.lastUpdate = currentTime;
        const positions = system.points.geometry.attributes.position.array;
        for (let j = 0; j < system.velocities.length; j++) {
          positions[j * 3] += system.velocities[j].x * dt;
          positions[j * 3 + 1] += system.velocities[j].y * dt;
          positions[j * 3 + 2] += system.velocities[j].z * dt;
        }
        system.points.geometry.attributes.position.needsUpdate = true;
        if (currentTime - system.startTime > 2000) {
          scene.remove(system.points);
          sparksSystems.splice(i, 1);
        }
      }
      
      if (!gameOver) {
        const remaining = updateCountdown();
        updateScoreDisplay();
        if (remaining <= 0) {
          endGame();
        }
      } else if (finalScreenCreated) {
        // Si se ha finalizado el juego, comprobamos colisiones con los botones de la pantalla final
        let interactionPoints = [];
        const session = renderer.xr.getSession();
        if (session && xrFrame) {
          for (const inputSource of session.inputSources) {
            if (inputSource.hand) {
              const indexTip = inputSource.hand.get('index-finger-tip');
              if (indexTip) {
                const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                if (jointPose) {
                  interactionPoints.push(new THREE.Vector3(
                    jointPose.transform.position.x,
                    jointPose.transform.position.y,
                    jointPose.transform.position.z
                  ));
                }
              }
            }
          }
        }
        if (interactionPoints.length === 0) {
          let cameraPos = new THREE.Vector3();
          camera.getWorldPosition(cameraPos);
          interactionPoints.push(cameraPos);
        }
        
        // Comprobar colisión con restartButtonMesh y exitButtonMesh
        interactionPoints.forEach(point => {
          if (restartButtonMesh && point.distanceTo(restartButtonMesh.position) < collisionThreshold) {
            // Reiniciar: recargar la página
            location.reload();
          }
          if (exitButtonMesh && point.distanceTo(exitButtonMesh.position) < collisionThreshold) {
            // Salir: actualizar el resumen final
            finalSummaryMesh.material.map.dispose();
            finalSummaryMesh.material.dispose();
            const exitCanvas = document.createElement('canvas');
            exitCanvas.width = 512;
            exitCanvas.height = 256;
            const exitCtx = exitCanvas.getContext('2d');
            exitCtx.fillStyle = "#007BFF";
            drawRoundedRect(exitCtx, 0, 0, exitCanvas.width, exitCanvas.height, 20);
            exitCtx.fillStyle = "#FFFFFF";
            exitCtx.font = "Bold 48px Arial";
            exitCtx.textAlign = "center";
            exitCtx.textBaseline = "middle";
            exitCtx.fillText("Gracias por jugar", exitCanvas.width / 2, exitCanvas.height / 2);
            const exitTexture = new THREE.CanvasTexture(exitCanvas);
            finalSummaryMesh.material.map = exitTexture;
            finalSummaryMesh.material.needsUpdate = true;
          }
        });
      }
      
      // Si el juego no ha terminado, procesar colisiones con respuestas
      if (!gameOver) {
        const session = renderer.xr.getSession();
        let interactionPoints = [];
        if (session && xrFrame) {
          for (const inputSource of session.inputSources) {
            if (inputSource.hand) {
              const indexTip = inputSource.hand.get('index-finger-tip');
              if (indexTip) {
                const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
                if (jointPose) {
                  interactionPoints.push(new THREE.Vector3(
                    jointPose.transform.position.x,
                    jointPose.transform.position.y,
                    jointPose.transform.position.z
                  ));
                }
              }
            }
          }
        }
        if (interactionPoints.length === 0) {
          let cameraPos = new THREE.Vector3();
          camera.getWorldPosition(cameraPos);
          interactionPoints.push(cameraPos);
        }
        
        for (let panel of answers) {
          const panelPos = new THREE.Vector3();
          panel.getWorldPosition(panelPos);
          for (const point of interactionPoints) {
            const distance = point.distanceTo(panelPos);
            if (distance < collisionThreshold && !hasCollided) {
              hasCollided = true;
              if (panel.userData.answer === correctAnswer) {
                correctCount++;
                const successSound = document.getElementById('successSound');
                const successClone = successSound.cloneNode();
                successClone.play().catch(e => console.error(e));
                createSparksEffect(panel.position);
                setTimeout(() => {
                  generateQuestion();
                  hasCollided = false;
                }, 500);
              } else {
                wrongCount++;
                const errorSound = document.getElementById('errorSound');
                const errorClone = errorSound.cloneNode();
                errorClone.play().catch(e => console.error(e));
                answers.forEach(a => a.material.color.set(0xff0000));
                setTimeout(() => {
                  answers.forEach(a => a.material.color.set(0xffffff));
                  hasCollided = false;
                }, 500);
              }
              return;
            }
          }
        }
      }
    }
    
    function endGame() {
      gameOver = true;
      // Eliminar elementos de juego
      if (questionMesh) scene.remove(questionMesh);
      if (countdownMesh) scene.remove(countdownMesh);
      if (scoreMesh) scene.remove(scoreMesh);
      answers.forEach(panel => scene.remove(panel));
      // Crear pantalla final en AR
      createFinalScreen();
    }
    
    // Desbloqueo de audio en móviles (solo success y error)
    window.addEventListener('touchstart', function unlockAudio() {
      const successEl = document.getElementById('successSound');
      const errorEl = document.getElementById('errorSound');
      [successEl, errorEl].forEach(audioEl => {
        audioEl.play().then(() => {
          audioEl.pause();
          audioEl.currentTime = 0;
        }).catch(e => console.error(e));
      });
    }, { once: true });
    
    init();
    animate();
  </script>
</body>
</html>
