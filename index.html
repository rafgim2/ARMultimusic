<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Multiplicación en AR con Bloques 3D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
  </style>
</head>
<body>
  <!-- Se utiliza audio para el sonido de acierto -->
  <audio id="successSound" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
  
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';
    import { RoundedBoxGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/geometries/RoundedBoxGeometry.js';
    
    let camera, scene, renderer;
    let correctAnswer;
    let answers = [];
    let hasCollided = false; // para evitar múltiples colisiones simultáneas
    let questionMesh = null;
    let questionText = "";
    const collisionThreshold = 0.2; // distancia (en metros) para considerar "colisión"
    
    // Array para almacenar sistemas de partículas (chispas)
    const sparksSystems = [];
    
    init();
    generateQuestion();
    createAnswerObjects();
    animate();
    
    // Desbloquea el audio en móviles con el primer toque
    window.addEventListener('touchstart', function unlockAudio() {
      const audioEl = document.getElementById('successSound');
      audioEl.play().then(() => {
        audioEl.pause();
        audioEl.currentTime = 0;
      }).catch(e => console.error(e));
    }, { once: true });
    
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Detectar si es móvil usando el user agent
      const isMobile = /Mobi|Android/i.test(navigator.userAgent);
      // En móviles, se solicita solo 'hit-test'; en otros, se solicita también 'hand-tracking'
      const requiredFeatures = isMobile ? ['hit-test'] : ['hit-test', 'hand-tracking'];
      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures }));
      
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);
      
      // Crea o actualiza el panel de la pregunta en AR
      updateQuestionPanel();
      
      window.addEventListener('resize', onWindowResize, false);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Genera una pregunta aleatoria y actualiza el panel en AR
    function generateQuestion() {
      const a = Math.floor(Math.random() * 10) + 1;
      const b = Math.floor(Math.random() * 10) + 1;
      correctAnswer = a * b;
      questionText = `¿Cuánto es ${a} x ${b}?`;
      updateQuestionPanel();
    }
    
    // Crea o actualiza el panel de la pregunta usando un canvas
    function updateQuestionPanel() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Fondo azul
      ctx.fillStyle = "#007BFF";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Dibujo del texto en blanco
      ctx.font = 'Bold 48px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(questionText, canvas.width / 2, canvas.height / 2);
      
      const texture = new THREE.CanvasTexture(canvas);
      
      // Usamos RoundedBoxGeometry para crear un bloque con profundidad y bordes redondeados
      const geometry = new RoundedBoxGeometry(0.6, 0.15, 0.05, 5, 0.02);
      // Creamos un arreglo de materiales: la cara frontal mostrará el canvas; las demás, un color azul
      // El orden de las caras es: [Right, Left, Top, Bottom, Front, Back]
      const frontMaterial = new THREE.MeshBasicMaterial({ map: texture });
      const sideMaterial = new THREE.MeshBasicMaterial({ color: 0x007BFF });
      const materials = [
        sideMaterial,
        sideMaterial,
        sideMaterial,
        sideMaterial,
        frontMaterial,
        sideMaterial
      ];
      
      if (questionMesh) {
        // Si ya existe, actualizamos el material de la cara frontal
        questionMesh.material[4] = frontMaterial;
        questionMesh.material.needsUpdate = true;
      } else {
        questionMesh = new THREE.Mesh(geometry, materials);
        // Posicionar el bloque de la pregunta: 0.3 m de altura y 0.8 m frente al usuario
        questionMesh.position.set(0, 0.3, -0.8);
        scene.add(questionMesh);
      }
    }
    
    // Crea los bloques de respuesta (uno correcto y tres incorrectos)
    function createAnswerObjects() {
      answers.forEach(panel => scene.remove(panel));
      answers = [];
      
      const wrongAnswers = new Set();
      while (wrongAnswers.size < 3) {
        let wrong = Math.floor(Math.random() * 100) + 1;
        if (wrong !== correctAnswer) wrongAnswers.add(wrong);
      }
      const answersArray = [correctAnswer, ...wrongAnswers];
      answersArray.sort(() => Math.random() - 0.5);
      
      const radius = 0.8; // separación mayor
      const total = answersArray.length;
      const angleStart = -Math.PI / 4;
      const angleEnd = Math.PI / 4;
      
      answersArray.forEach((num, index) => {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Fondo azul
        ctx.fillStyle = "#007BFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Texto en blanco, tamaño 75px
        ctx.font = 'Bold 75px Arial';
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(num, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        // Usamos RoundedBoxGeometry para crear un bloque con profundidad (0.15 x 0.15 x 0.05 m)
        const geometry = new RoundedBoxGeometry(0.15, 0.15, 0.05, 5, 0.02);
        // Arreglo de materiales para el bloque: la cara frontal con el canvas y el resto en azul.
        const frontMaterial = new THREE.MeshBasicMaterial({ map: texture });
        const sideMaterial = new THREE.MeshBasicMaterial({ color: 0x007BFF });
        const materials = [
          sideMaterial,
          sideMaterial,
          sideMaterial,
          sideMaterial,
          frontMaterial,
          sideMaterial
        ];
        const mesh = new THREE.Mesh(geometry, materials);
        
        let angle = total === 1 ? 0 : angleStart + (angleEnd - angleStart) * (index / (total - 1));
        const x = radius * Math.sin(angle);
        const z = -radius * Math.cos(angle);
        mesh.position.set(x, 0, z);
        mesh.userData = { answer: num };
        answers.push(mesh);
        scene.add(mesh);
      });
    }
    
    // Crea un efecto de chispas en la posición indicada
    function createSparksEffect(position) {
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      for (let i = 0; i < count; i++) {
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;
        velocities.push(new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ));
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.02 });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      sparksSystems.push({
        points,
        velocities,
        startTime: performance.now(),
        lastUpdate: performance.now()
      });
    }
    
    // Bucle de animación: se detecta la "colisión" usando hand tracking (para ambas manos) o la cámara en móviles
    function animate() {
      renderer.setAnimationLoop(render);
    }
    
    function render(timestamp, xrFrame) {
      renderer.render(scene, camera);
      
      // Actualiza sistemas de chispas
      const currentTime = performance.now();
      for (let i = sparksSystems.length - 1; i >= 0; i--) {
        const system = sparksSystems[i];
        const dt = (currentTime - system.lastUpdate) / 1000;
        system.lastUpdate = currentTime;
        const posArray = system.points.geometry.attributes.position.array;
        for (let j = 0; j < system.velocities.length; j++) {
          posArray[j * 3] += system.velocities[j].x * dt;
          posArray[j * 3 + 1] += system.velocities[j].y * dt;
          posArray[j * 3 + 2] += system.velocities[j].z * dt;
        }
        system.points.geometry.attributes.position.needsUpdate = true;
        if (currentTime - system.startTime > 2000) {
          scene.remove(system.points);
          sparksSystems.splice(i, 1);
        }
      }
      
      // Recopila los puntos de interacción: se usan los datos de ambas manos si están disponibles; si no, se usa la cámara
      const session = renderer.xr.getSession();
      let interactionPoints = [];
      if (session && xrFrame) {
        for (const inputSource of session.inputSources) {
          if (inputSource.hand) {
            const indexTip = inputSource.hand.get('index-finger-tip');
            if (indexTip) {
              const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
              if (jointPose) {
                interactionPoints.push(new THREE.Vector3(
                  jointPose.transform.position.x,
                  jointPose.transform.position.y,
                  jointPose.transform.position.z
                ));
              }
            }
          }
        }
      }
      if (interactionPoints.length === 0) {
        let cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        interactionPoints.push(cameraPos);
      }
      
      // Comprueba la "colisión" entre cada bloque de respuesta y cada punto de interacción
      for (let panel of answers) {
        const panelPos = new THREE.Vector3();
        panel.getWorldPosition(panelPos);
        for (const point of interactionPoints) {
          const distance = point.distanceTo(panelPos);
          if (distance < collisionThreshold && !hasCollided) {
            hasCollided = true;
            if (panel.userData.answer === correctAnswer) {
              document.getElementById('successSound').play().catch(e => console.error(e));
              createSparksEffect(panel.position);
              scene.remove(panel);
            }
            setTimeout(() => {
              generateQuestion();
              createAnswerObjects();
              hasCollided = false;
            }, 2000);
            return; // Se procesa solo una colisión a la vez
          }
        }
      }
    }
  </script>
</body>
</html>
