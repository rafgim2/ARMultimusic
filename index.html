<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>AR MULTIMUSIC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    /* Overlay del menú inicial */
    #overlay {
      position: absolute;
      padding-top: 100px; /* Ajusta este valor según necesites */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: orange;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      color: #fff;
      text-align: center;
      z-index: 10;
    }
    #overlay a {
      font-size: 14px;
      margin-top: -10px;
      margin-bottom: 20px;
      color: blue;
      text-decoration: none;
    }
    /* Contenedor para el selector de respuestas */
    #overlay .respuestas-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    #overlay .respuestas-container label {
      font-size: 14px;
    }
    #overlay .respuestas-container select {
      font-size: 14px;
    }
    /* Estilos responsivos para la imagen */
    #overlay img {
      border-radius: 20px;
      max-width: 15%;
    }
    @media (orientation: portrait) {
      /* En móviles verticales se usa un tamaño mayor */
      #overlay img {
        max-width: 70%;
      }
    }
    /* Estilo para el botón de trivia */
    #triviaButton {
      font-size: 16px;
      padding: 10px 20px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Audios: acierto, error, timer y beep -->
  <audio id="successSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/acierto.wav" preload="auto"></audio>
  <audio id="errorSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/error.wav" preload="auto"></audio>
  <audio id="timerSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/timer7.mp3" preload="auto"></audio>
  <audio id="beepSound" src="https://raw.githubusercontent.com/rafgim2/ARMultimusic/main/beep.wav" preload="auto"></audio>
  
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.module.js';
    // Si no es móvil, se solicita además hand-tracking
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const requiredFeatures = isMobile ? ['hit-test'] : ['hit-test', 'hand-tracking'];
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.138.0/examples/jsm/webxr/ARButton.js';
    
    let camera, scene, renderer;
    let correctAnswer;
    let answers = []; // Paneles de respuesta
    let hasCollided = false;
    let questionMesh = null;
    let questionText = "";
    const collisionThreshold = 0.2;
    const sparksSystems = [];
    
    // Contadores de aciertos y fallos
    let correctCount = 0;
    let wrongCount = 0;
    
    // Variables para el tiempo de juego
    let gameStartTime = 0;
    const gameDuration = 60; // segundos
    let gameOver = false;
    
    // Mallas en AR: cuenta atrás y score
    let countdownMesh = null, countdownCanvas = null, countdownCtx = null, countdownTexture = null;
    let scoreMesh = null, scoreCanvas = null, scoreCtx = null, scoreTexture = null;
    
    // Botón final: se mantiene solo el de Reiniciar
    let restartButtonMesh = null, finalMessageMesh = null;
    
    // Número de respuestas seleccionado (por defecto se usa el selector para modo multiplicación)
    let selectedNumAnswers = 4;
    
    // Variable para controlar el beep (se reproducirá solo una vez cuando falten 10 segundos)
    let beepPlayed = false;
    
    // Variables para controlar el inicio del countdown y audio al primer render con la escena lista
    let gameReady = false;
    let countdownStarted = false;
    
    // Factor para mejorar la resolución de los canvas (multiplicador)
    const resolutionFactor = 4;
    
    // Variable para modo de juego: "multiplication" o "trivia"
    let gameMode = "multiplication";
    
    /* Helper para ajustar (wrap) texto en líneas */
    function getWrappedLines(ctx, text, maxWidth) {
      const words = text.split(' ');
      const lines = [];
      let currentLine = words[0];
      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const testLine = currentLine + ' ' + word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      lines.push(currentLine);
      return lines;
    }
    
    // Función para dibujar un rectángulo redondeado
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }
    
    // Función para actualizar el panel de respuesta con mayor resolución
    function updateAnswerPanel(mesh, value) {
      const canvas = document.createElement('canvas');
      canvas.width = 256 * resolutionFactor;
      canvas.height = 256 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
      ctx.shadowBlur = 10 * resolutionFactor;
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      ctx.shadowBlur = 0;
      // En modo trivia usamos un tamaño de fuente menor y texto envuelto
      let fontSize = (gameMode === "trivia") ? 24 * resolutionFactor : 75 * resolutionFactor;
      ctx.font = 'Bold ' + fontSize + 'px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (gameMode === "trivia") {
        const margin = 20 * resolutionFactor;
        const maxWidth = canvas.width - 2 * margin;
        const lineHeight = fontSize * 1.2;
        const lines = getWrappedLines(ctx, value.toString(), maxWidth);
        const totalTextHeight = lines.length * lineHeight;
        let startY = (canvas.height - totalTextHeight) / 2 + lineHeight / 2;
        for (const line of lines) {
          ctx.fillText(line, canvas.width / 2, startY);
          startY += lineHeight;
        }
      } else {
        ctx.fillText(value, canvas.width / 2, canvas.height / 2);
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      mesh.material.map = texture;
      mesh.material.needsUpdate = true;
      mesh.userData.answer = value;
    }
    
    // Función para decodificar entidades HTML (útil para la API de trivia)
    function decodeHTML(html) {
      let txt = document.createElement("textarea");
      txt.innerHTML = html;
      return txt.value;
    }
    
    // Función para inicializar la escena AR
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);
      
      window.addEventListener('resize', onWindowResize, false);
      
      // Crear overlay inicial
      const overlay = document.createElement('div');
      overlay.id = 'overlay';
      overlay.innerHTML =
        '<img src="armult.png" alt="AR Mult" style="margin-bottom:20px;">' +
        '<a href="https://www.youtube.com/@rafgim" target="_blank">© By Rafael Gimeno</a>' +
        '<div class="respuestas-container">' +
          '<label for="numAnswers">Respuestas:</label>' +
          '<select id="numAnswers">' +
            '<option value="4">4</option>' +
            '<option value="5">5</option>' +
            '<option value="6">6</option>' +
            '<option value="7">7</option>' +
            '<option value="8">8</option>' +
            '<option value="9">9</option>' +
            '<option value="10">10</option>' +
          '</select>' +
        '</div>' +
        '<button id="triviaButton">4º de primaria</button>';
      
      document.body.appendChild(overlay);
      
      // Listener para el botón de trivia: al pulsarlo se activa el modo trivia, se fija 4 respuestas y se pone verde.
      document.getElementById('triviaButton').addEventListener('click', function() {
        gameMode = "trivia";
        selectedNumAnswers = 4;
        this.style.backgroundColor = "green";
        // Se deshabilita el selector para modo multiplicación
        document.getElementById('numAnswers').disabled = true;
      });
      
      // Crear el botón AR con estilos personalizados
      const arButton = ARButton.createButton(renderer, { requiredFeatures });
      if (arButton.parentNode) {
        arButton.parentNode.removeChild(arButton);
      }
      arButton.style.position = 'absolute';
      arButton.style.top = '450px';
      arButton.style.left = '100%';
      arButton.style.transform = 'translateX(0%)';
      arButton.style.width = '150px';
      arButton.style.height = '50px';
      arButton.style.fontSize = '16px';
      arButton.style.backgroundColor = 'green';
      arButton.style.color = 'white';
      overlay.appendChild(arButton);
      
      renderer.xr.addEventListener('sessionstart', () => {
        if (gameMode === "multiplication") {
          selectedNumAnswers = parseInt(document.getElementById('numAnswers').value) || 4;
          // Para modo multiplicación se crean los paneles inicialmente
          createAnswerObjects(selectedNumAnswers, true);
        }
        overlay.remove();
        generateQuestion();
        createScoreDisplay();
        gameReady = true;
      });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Función para iniciar el conteo regresivo
    function startCountdown() {
      gameStartTime = performance.now();
      countdownCanvas = document.createElement('canvas');
      countdownCanvas.width = 256 * resolutionFactor;
      countdownCanvas.height = 128 * resolutionFactor;
      countdownCtx = countdownCanvas.getContext('2d');
      countdownTexture = new THREE.CanvasTexture(countdownCanvas);
      countdownTexture.minFilter = THREE.LinearFilter;
      countdownTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.6, 0.3);
      const material = new THREE.MeshBasicMaterial({ map: countdownTexture, transparent: true });
      countdownMesh = new THREE.Mesh(geometry, material);
      countdownMesh.position.set(0, 0.50, -0.82);
      scene.add(countdownMesh);
    }
    
    // Función para crear la visualización del score durante el juego
    function createScoreDisplay() {
      scoreCanvas = document.createElement('canvas');
      scoreCanvas.width = 256 * resolutionFactor;
      scoreCanvas.height = 128 * resolutionFactor;
      scoreCtx = scoreCanvas.getContext('2d');
      scoreTexture = new THREE.CanvasTexture(scoreCanvas);
      scoreTexture.minFilter = THREE.LinearFilter;
      scoreTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.6, 0.3);
      const material = new THREE.MeshBasicMaterial({ map: scoreTexture, transparent: true });
      scoreMesh = new THREE.Mesh(geometry, material);
      scoreMesh.position.set(0, -0.2, -0.8);
      scene.add(scoreMesh);
    }
    
    // Se ajustaron las dimensiones y se implementó el "wrap" para que se muestre todo el texto
    function updateQuestionPanel() {
      const canvas = document.createElement('canvas');
      // Dimensiones mayores para mostrar textos más largos
      canvas.width = 768 * resolutionFactor;
      canvas.height = 192 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
      ctx.shadowBlur = 10 * resolutionFactor;
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
      ctx.shadowBlur = 0;
      const fontSize = 32 * resolutionFactor;
      ctx.font = 'Bold ' + fontSize + 'px Arial';
      ctx.fillStyle = "#FFFFFF";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const margin = 20 * resolutionFactor;
      const maxWidth = canvas.width - 2 * margin;
      const lineHeight = fontSize * 1.2;
      const lines = getWrappedLines(ctx, questionText, maxWidth);
      const totalTextHeight = lines.length * lineHeight;
      let startY = (canvas.height - totalTextHeight) / 2 + lineHeight / 2;
      for (const line of lines) {
        ctx.fillText(line, canvas.width / 2, startY);
        startY += lineHeight;
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      if (questionMesh) {
        questionMesh.material.map = texture;
        questionMesh.material.needsUpdate = true;
      } else {
        const geometry = new THREE.PlaneGeometry(0.8, 0.25);
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
        questionMesh = new THREE.Mesh(geometry, material);
        questionMesh.position.set(0, 0.3, -0.8);
        scene.add(questionMesh);
      }
    }
    
    // Modo multiplicación: crea paneles con números (sin wrap en trivia se usa updateAnswerPanel)
    function createAnswerObjects(numAnswers, initialCreation) {
      if (initialCreation) {
        const minArc = 1.39626;
        const maxArc = Math.PI;
        let arcAngle = (numAnswers <= 4) ? minArc : (numAnswers >= 10 ? maxArc : minArc + ((numAnswers - 4) / (10 - 4)) * (maxArc - minArc));
        const angleStart = -arcAngle / 2;
        const angleEnd = arcAngle / 2;
        const radius = 0.8;
        for (let i = 0; i < numAnswers; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = 256 * resolutionFactor;
          canvas.height = 256 * resolutionFactor;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.shadowBlur = 10 * resolutionFactor;
          ctx.fillStyle = "#007BFF";
          drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
          ctx.shadowBlur = 0;
          ctx.font = 'Bold ' + (75 * resolutionFactor) + 'px Arial';
          ctx.fillStyle = "#FFFFFF";
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const wrongAnswers = new Set();
          while (wrongAnswers.size < (numAnswers - 1)) {
            let wrong = Math.floor(Math.random() * 100) + 1;
            if (wrong !== correctAnswer) wrongAnswers.add(wrong);
          }
          const answersArray = [correctAnswer, ...wrongAnswers];
          answersArray.sort(() => Math.random() - 0.5);
          ctx.fillText(answersArray[i], canvas.width / 2, canvas.height / 2);
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
          const geometry = new THREE.PlaneGeometry(0.15, 0.15);
          const mesh = new THREE.Mesh(geometry, material);
          const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
          const x = radius * Math.sin(angle);
          const z = -radius * Math.cos(angle);
          mesh.position.set(x, 0, z);
          const cameraWorldPos = new THREE.Vector3();
          camera.getWorldPosition(cameraWorldPos);
          const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
          mesh.lookAt(lookAtPos);
          mesh.userData.answer = answersArray[i];
          answers.push(mesh);
          scene.add(mesh);
        }
      } else {
        const numAnswersExisting = selectedNumAnswers;
        const wrongAnswers = new Set();
        while (wrongAnswers.size < (numAnswersExisting - 1)) {
          let wrong = Math.floor(Math.random() * 100) + 1;
          if (wrong !== correctAnswer) wrongAnswers.add(wrong);
        }
        const answersArray = [correctAnswer, ...wrongAnswers];
        answersArray.sort(() => Math.random() - 0.5);
        for (let i = 0; i < numAnswersExisting; i++) {
          updateAnswerPanel(answers[i], answersArray[i]);
        }
      }
    }
    
    // Modo trivia: crea paneles de respuestas usando wrap para textos largos
    function createTriviaAnswerObjects(answersArray) {
      answers.forEach(panel => scene.remove(panel));
      answers = [];
      const numAnswers = answersArray.length;
      const minArc = 1.39626;
      const maxArc = Math.PI;
      let arcAngle = (numAnswers <= 4) ? minArc : (numAnswers >= 10 ? maxArc : minArc + ((numAnswers - 4) / (10 - 4)) * (maxArc - minArc));
      const angleStart = -arcAngle / 2;
      const angleEnd = arcAngle / 2;
      const radius = 0.8;
      for (let i = 0; i < numAnswers; i++) {
        const canvas = document.createElement('canvas');
        canvas.width = 256 * resolutionFactor;
        canvas.height = 256 * resolutionFactor;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
        ctx.shadowBlur = 10 * resolutionFactor;
        ctx.fillStyle = "#007BFF";
        drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 20 * resolutionFactor);
        ctx.shadowBlur = 0;
        let fontSize = 24 * resolutionFactor;
        ctx.font = 'Bold ' + fontSize + 'px Arial';
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const margin = 20 * resolutionFactor;
        const maxWidth = canvas.width - 2 * margin;
        const lineHeight = fontSize * 1.2;
        const lines = getWrappedLines(ctx, answersArray[i], maxWidth);
        const totalTextHeight = lines.length * lineHeight;
        let startY = (canvas.height - totalTextHeight) / 2 + lineHeight / 2;
        for (const line of lines) {
          ctx.fillText(line, canvas.width / 2, startY);
          startY += lineHeight;
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        const geometry = new THREE.PlaneGeometry(0.15, 0.15);
        const mesh = new THREE.Mesh(geometry, material);
        const angle = angleStart + (angleEnd - angleStart) * (i / (numAnswers - 1));
        const x = radius * Math.sin(angle);
        const z = -radius * Math.cos(angle);
        mesh.position.set(x, 0, z);
        const cameraWorldPos = new THREE.Vector3();
        camera.getWorldPosition(cameraWorldPos);
        const lookAtPos = new THREE.Vector3(cameraWorldPos.x, mesh.position.y, cameraWorldPos.z);
        mesh.lookAt(lookAtPos);
        mesh.userData.answer = answersArray[i];
        answers.push(mesh);
        scene.add(mesh);
      }
    }
    
    function updateAnswerObjects() {
      createAnswerObjects(selectedNumAnswers, false);
    }
    
    // Función para crear efecto de chispas
    function createSparksEffect(position) {
      const count = 100;
      const positions = new Float32Array(count * 3);
      const velocities = [];
      for (let i = 0; i < count; i++) {
        positions[i * 3] = position.x;
        positions[i * 3 + 1] = position.y;
        positions[i * 3 + 2] = position.z;
        velocities.push(new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ));
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.02 });
      const points = new THREE.Points(geometry, material);
      scene.add(points);
      sparksSystems.push({
        points,
        velocities,
        startTime: performance.now(),
        lastUpdate: performance.now()
      });
    }
    
    function animate() {
      renderer.setAnimationLoop(render);
    }
    
    function render(timestamp, xrFrame) {
      renderer.render(scene, camera);
      if (gameReady && !countdownStarted) {
        startCountdown();
        const timerSound = document.getElementById('timerSound');
        timerSound.loop = false;
        timerSound.play().catch(e => console.error(e));
        countdownStarted = true;
      }
      const currentTime = performance.now();
      for (let i = sparksSystems.length - 1; i >= 0; i--) {
        const system = sparksSystems[i];
        const dt = (currentTime - system.lastUpdate) / 1000;
        system.lastUpdate = currentTime;
        const positions = system.points.geometry.attributes.position.array;
        for (let j = 0; j < system.velocities.length; j++) {
          positions[j * 3] += system.velocities[j].x * dt;
          positions[j * 3 + 1] += system.velocities[j].y * dt;
          positions[j * 3 + 2] += system.velocities[j].z * dt;
        }
        system.points.geometry.attributes.position.needsUpdate = true;
        if (currentTime - system.startTime > 2000) {
          scene.remove(system.points);
          sparksSystems.splice(i, 1);
        }
      }
      if (!gameOver) {
        const remaining = updateCountdown();
        updateScoreDisplay();
        if (remaining <= 0) {
          endGame();
        }
      }
      const session = renderer.xr.getSession();
      let interactionPoints = [];
      if (session && xrFrame) {
        for (const inputSource of session.inputSources) {
          if (inputSource.hand) {
            const indexTip = inputSource.hand.get('index-finger-tip');
            if (indexTip) {
              const jointPose = xrFrame.getJointPose(indexTip, renderer.xr.getReferenceSpace());
              if (jointPose) {
                interactionPoints.push(new THREE.Vector3(
                  jointPose.transform.position.x,
                  jointPose.transform.position.y,
                  jointPose.transform.position.z
                ));
              }
            }
          }
        }
      }
      if (interactionPoints.length === 0) {
        let cameraPos = new THREE.Vector3();
        camera.getWorldPosition(cameraPos);
        interactionPoints.push(cameraPos);
      }
      if (!gameOver) {
        for (let panel of answers) {
          const panelPos = new THREE.Vector3();
          panel.getWorldPosition(panelPos);
          for (const point of interactionPoints) {
            const distance = point.distanceTo(panelPos);
            if (distance < collisionThreshold && !hasCollided) {
              hasCollided = true;
              if (panel.userData.answer === correctAnswer) {
                correctCount++;
                const successSound = document.getElementById('successSound');
                const successClone = successSound.cloneNode();
                successClone.play().catch(e => console.error(e));
                createSparksEffect(panel.position);
                if (questionMesh) questionMesh.visible = false;
                answers.forEach(a => a.visible = false);
                setTimeout(() => {
                  if (!gameOver) {
                    generateQuestion();
                    if(questionMesh) questionMesh.visible = true;
                    answers.forEach(a => a.visible = true);
                  }
                  hasCollided = false;
                }, 1000);
              } else {
                wrongCount++;
                const errorSound = document.getElementById('errorSound');
                const errorClone = errorSound.cloneNode();
                errorClone.play().catch(e => console.error(e));
                answers.forEach(a => a.material.color.set(0xff0000));
                setTimeout(() => {
                  answers.forEach(a => a.material.color.set(0xffffff));
                  hasCollided = false;
                }, 500);
              }
              return;
            }
          }
        }
      } else {
        if (restartButtonMesh) {
          const buttonPos = new THREE.Vector3();
          restartButtonMesh.getWorldPosition(buttonPos);
          for (const point of interactionPoints) {
            const distance = point.distanceTo(buttonPos);
            if (distance < collisionThreshold && !hasCollided) {
              hasCollided = true;
              const successSound = document.getElementById('successSound');
              const successClone = successSound.cloneNode();
              successClone.play().catch(e => console.error(e));
              createSparksEffect(restartButtonMesh.position);
              restartButtonMesh.visible = false;
              setTimeout(() => {
                restartGame();
                hasCollided = false;
              }, 1000);
              break;
            }
          }
        }
      }
    }
    
    async function generateQuestion() {
      if (gameMode === "trivia") {
        try {
          // Se solicita una pregunta de trivia en español (se añade &lang=es)
          const response = await fetch("https://opentdb.com/api.php?amount=1&category=9&difficulty=easy&type=multiple&lang=es");
          const data = await response.json();
          if (data.response_code === 0 && data.results.length > 0) {
            const result = data.results[0];
            const question = decodeHTML(result.question);
            const correct = decodeHTML(result.correct_answer);
            const incorrects = result.incorrect_answers.map(decodeHTML);
            correctAnswer = correct;
            questionText = question;
            updateQuestionPanel();
            let answersArray = [correct, ...incorrects];
            answersArray.sort(() => Math.random() - 0.5);
            createTriviaAnswerObjects(answersArray);
            beepPlayed = false;
          } else {
            console.error("No se obtuvo pregunta de trivia");
          }
        } catch (err) {
          console.error("Error al obtener pregunta de trivia: ", err);
        }
      } else {
        const a = Math.floor(Math.random() * 10) + 1;
        const b = Math.floor(Math.random() * 10) + 1;
        correctAnswer = a * b;
        questionText = `¿Cuánto es ${a} x ${b}?`;
        if(questionMesh) {
          scene.remove(questionMesh);
          questionMesh = null;
        }
        updateQuestionPanel();
        updateAnswerObjects();
        beepPlayed = false;
      }
    }
    
    function endGame() {
      gameOver = true;
      if (questionMesh) scene.remove(questionMesh);
      if (countdownMesh) scene.remove(countdownMesh);
      if (scoreMesh) scene.remove(scoreMesh);
      answers.forEach(panel => scene.remove(panel));
      const gameOverCanvas = document.createElement('canvas');
      gameOverCanvas.width = 256 * resolutionFactor;
      gameOverCanvas.height = 128 * resolutionFactor;
      const gameOverCtx = gameOverCanvas.getContext('2d');
      gameOverCtx.fillStyle = "#007BFF";
      drawRoundedRect(gameOverCtx, 0, 0, gameOverCanvas.width, gameOverCanvas.height, 10 * resolutionFactor);
      gameOverCtx.fillStyle = "#FFFFFF";
      gameOverCtx.font = 'Bold ' + (24 * resolutionFactor) + 'px Arial';
      gameOverCtx.textAlign = "center";
      gameOverCtx.textBaseline = "middle";
      gameOverCtx.fillText("Fin del Juego", gameOverCanvas.width / 2, 30 * resolutionFactor);
      gameOverCtx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
      gameOverCtx.fillText(`Aciertos: ${correctCount}`, gameOverCanvas.width / 2, 65 * resolutionFactor);
      gameOverCtx.fillText(`Fallos: ${wrongCount}`, gameOverCanvas.width / 2, 100 * resolutionFactor);
      const gameOverTexture = new THREE.CanvasTexture(gameOverCanvas);
      gameOverTexture.minFilter = THREE.LinearFilter;
      gameOverTexture.magFilter = THREE.LinearFilter;
      const geometry = new THREE.PlaneGeometry(0.5, 0.25);
      const material = new THREE.MeshBasicMaterial({ map: gameOverTexture, transparent: true });
      finalMessageMesh = new THREE.Mesh(geometry, material);
      finalMessageMesh.position.set(0, 0, -0.8);
      scene.add(finalMessageMesh);
      restartButtonMesh = createButton("Reiniciar");
      restartButtonMesh.position.set(0, -0.3, -0.8);
      scene.add(restartButtonMesh);
    }
    
    function createButton(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 128 * resolutionFactor;
      canvas.height = 64 * resolutionFactor;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = "#007BFF";
      drawRoundedRect(ctx, 0, 0, canvas.width, canvas.height, 10 * resolutionFactor);
      ctx.fillStyle = "#FFFFFF";
      ctx.font = 'Bold ' + (18 * resolutionFactor) + 'px Arial';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      const geom = new THREE.PlaneGeometry(0.2, 0.1);
      const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      return new THREE.Mesh(geom, mat);
    }
    
    function restartGame() {
      if(finalMessageMesh) scene.remove(finalMessageMesh);
      if(restartButtonMesh) scene.remove(restartButtonMesh);
      if (questionMesh) {
        scene.remove(questionMesh);
        questionMesh = null;
      }
      correctCount = 0;
      wrongCount = 0;
      gameStartTime = performance.now();
      gameOver = false;
      answers.forEach(panel => scene.remove(panel));
      answers = [];
      if (gameMode === "multiplication") {
        createAnswerObjects(selectedNumAnswers, true);
      }
      generateQuestion();
      countdownStarted = false;
      gameReady = true;
      createScoreDisplay();
      const timerSound = document.getElementById('timerSound');
      timerSound.currentTime = 0;
      timerSound.loop = false;
      timerSound.play().catch(e => console.error(e));
    }
    
    // Listener para desbloquear el audio en móviles (solo se ejecuta una vez)
    window.addEventListener('touchstart', function unlockAudio() {
      const successEl = document.getElementById('successSound');
      const errorEl = document.getElementById('errorSound');
      [successEl, errorEl].forEach(audioEl => {
        audioEl.play().then(() => {
          audioEl.pause();
          audioEl.currentTime = 0;
        }).catch(e => console.error(e));
      });
    }, { once: true });
    
    // Listener adicional para detectar toques y procesar la respuesta
    window.addEventListener('touchstart', function(event) {
      if (!/Mobi|Android/i.test(navigator.userAgent)) return;
      const touch = event.touches[0];
      const x = (touch.clientX / window.innerWidth) * 2 - 1;
      const y = - (touch.clientY / window.innerHeight) * 2 + 1;
      const mouseVector = new THREE.Vector2(x, y);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouseVector, camera);
      let objectsToIntersect = [];
      if (!gameOver) {
        objectsToIntersect = answers;
      } else {
        if (restartButtonMesh) {
          objectsToIntersect = [restartButtonMesh];
        }
      }
      const intersects = raycaster.intersectObjects(objectsToIntersect);
      if (intersects.length > 0 && !hasCollided) {
        const panel = intersects[0].object;
        hasCollided = true;
        if (!gameOver) {
          if (panel.userData.answer === correctAnswer) {
            correctCount++;
            const successSound = document.getElementById('successSound');
            const successClone = successSound.cloneNode();
            successClone.play().catch(e => console.error(e));
            createSparksEffect(panel.position);
            if (questionMesh) questionMesh.visible = false;
            answers.forEach(a => a.visible = false);
            setTimeout(() => {
              if (!gameOver) {
                generateQuestion();
                if(questionMesh) questionMesh.visible = true;
                answers.forEach(a => a.visible = true);
              }
              hasCollided = false;
            }, 1000);
          } else {
            wrongCount++;
            const errorSound = document.getElementById('errorSound');
            const errorClone = errorSound.cloneNode();
            errorClone.play().catch(e => console.error(e));
            answers.forEach(a => a.material.color.set(0xff0000));
            setTimeout(() => {
              answers.forEach(a => a.material.color.set(0xffffff));
              hasCollided = false;
            }, 500);
          }
        } else {
          const successSound = document.getElementById('successSound');
          const successClone = successSound.cloneNode();
          successClone.play().catch(e => console.error(e));
          createSparksEffect(panel.position);
          panel.visible = false;
          setTimeout(() => {
            restartGame();
            hasCollided = false;
          }, 1000);
        }
      }
    }, false);
    
    init();
    animate();
  </script>
</body>
</html>
